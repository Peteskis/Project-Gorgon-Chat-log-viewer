<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Project Gorgon Chat Log Viewer</title>
  <style>
    :root{
      --bg:#0b1020; --panel:#0f172a; --panel2:#111c36; --text:#e5e7eb; --muted:#94a3b8;
      --border:rgba(148,163,184,.18); --accent:#60a5fa; --accent2:#22c55e; --warn:#f59e0b; --danger:#fb7185;
      --shadow: 0 12px 30px rgba(0,0,0,.35); --radius:14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:var(--sans); background:
        radial-gradient(1200px 600px at 20% 10%, rgba(96,165,250,.18), transparent 60%),
        radial-gradient(1000px 600px at 80% 10%, rgba(34,197,94,.10), transparent 60%),
        var(--bg);
      color:var(--text); line-height:1.35;
    }
    header{
      position:sticky; top:0; z-index:10;
      background: linear-gradient(180deg, rgba(11,16,32,.96), rgba(11,16,32,.86));
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--border);
    }
    .wrap{max-width:1600px;margin:0 auto;padding:18px 16px}
    .topbar{display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap;}
    .title{display:flex; gap:10px; align-items:baseline; flex-wrap:wrap;}
    .title h1{margin:0;font-size:18px;letter-spacing:.2px}
    .title .sub{color:var(--muted);font-size:13px}
    .controls{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .btn, .chip, input[type="text"], textarea, select{
      border:1px solid var(--border);
      background: rgba(15,23,42,.65);
      color:var(--text);
      border-radius:12px;
      padding:10px 12px;
      font-size:13px;
      outline:none;
    }
    .btn{cursor:pointer; transition: transform .06s ease, border-color .2s ease, background .2s ease; user-select:none;}
    .btn:hover{border-color: rgba(96,165,250,.55); background: rgba(15,23,42,.88)}
    .btn:active{transform: translateY(1px)}
    input[type="file"]{display:none}
    .chip{padding:8px 10px; display:inline-flex; gap:8px; align-items:center;}
    .chip b{font-weight:600}
    .grid{display:grid; grid-template-columns: 1fr; gap:14px; margin-top:14px;}
    @media(min-width:960px){ .grid{grid-template-columns: 480px 1fr} }
    .card{
      background: linear-gradient(180deg, rgba(15,23,42,.85), rgba(15,23,42,.65));
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card header{position:unset; background:none; border-bottom:1px solid var(--border);}
    .card h2{margin:0; font-size:13px; letter-spacing:.3px; text-transform:uppercase; color:var(--muted);}
    .card .body{padding:14px}
    .drop{
      border: 1px dashed rgba(148,163,184,.35);
      background: rgba(17,28,54,.35);
      border-radius: 12px;
      padding: 14px;
      color: var(--muted);
      font-size: 13px;
      display:flex; flex-direction:column; gap:10px;
      min-height: 160px; justify-content:center; align-items:center; text-align:center;
    }
    .drop.drag{border-color: rgba(96,165,250,.8); background: rgba(96,165,250,.08); color: var(--text)}
    textarea{width:100%; min-height: 120px; resize: vertical; font-family: var(--mono); background: rgba(11,16,32,.35);}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap; width:100%;}
    .row .grow{flex:1}
    .muted{color:var(--muted)}
    .tabs{display:flex; gap:8px; flex-wrap:wrap; padding:12px; border-bottom:1px solid var(--border); background: rgba(17,28,54,.25);}
    .tab{
      border:1px solid var(--border); background: rgba(15,23,42,.55);
      padding:8px 10px; border-radius: 999px; font-size: 13px; cursor:pointer;
      display:inline-flex; align-items:center; gap:8px; user-select:none;
      transition: border-color .2s ease, background .2s ease;
    }
    .tab:hover{border-color: rgba(96,165,250,.55)}
    .tab.active{border-color: rgba(96,165,250,.9); background: rgba(96,165,250,.14);}
    .badge{font-size:12px; padding:2px 8px; border-radius: 999px; border: 1px solid var(--border); color: var(--muted);}
    .viewer{height: calc(100vh - 240px); min-height: 520px; overflow:auto; background: rgba(11,16,32,.25);}
    .msg{
      display:grid; grid-template-columns: 170px 130px 1fr; gap:10px;
      border-left: 4px solid var(--cEdge, transparent);
      padding:10px 12px; border-bottom:1px solid rgba(148,163,184,.10);
      font-family: var(--mono); font-size: 13px; line-height:1.35;
    }
    .msg:hover{background: rgba(96,165,250,.06)}
    .ts{color: var(--muted)}
    .chan{display:inline-flex; align-items:center; gap:8px; white-space:nowrap;}
    .pill{
      display:inline-flex; align-items:center; border-radius: 999px;
      padding:2px 8px;
      border:1px solid var(--cBorder, rgba(148,163,184,.22));
      background: var(--cBg, rgba(15,23,42,.6));
      color: var(--text);
      font-size: 12px;
    }
    .pill.status{border-color: rgba(245,158,11,.35); background: rgba(245,158,11,.10)}
    .pill.global{border-color: rgba(96,165,250,.35); background: rgba(96,165,250,.10)}
    .pill.help{border-color: rgba(34,197,94,.35); background: rgba(34,197,94,.10)}
    .pill.nearby{border-color: rgba(244,63,94,.30); background: rgba(244,63,94,.10)}
    .from{color: var(--c, #cbd5e1); font-weight:600}
    .text{white-space:pre-wrap; word-break:break-word; color: var(--c, var(--text))}
    .statusLine{color: #fcd34d}
    .foot{
      padding:10px 12px; display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap;
      border-top:1px solid var(--border); background: rgba(17,28,54,.25); color: var(--muted); font-size: 12px;
    }
    .k{display:inline-flex; gap:6px; align-items:center; padding: 6px 10px; border-radius: 999px;
      border:1px solid rgba(148,163,184,.20); background: rgba(15,23,42,.45); color: var(--muted); font-family: var(--mono); font-size: 12px;}
    .sep{opacity:.35}

    .folderBox{
      width:100%;
      border:1px solid rgba(148,163,184,.20);
      background: rgba(11,16,32,.20);
      border-radius: 12px;
      padding: 12px;
      display:flex;
      flex-direction:column;
      gap:10px;
      text-align:left;
    }
    .folderHeader{display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;}
    .folderHeader .label{color:var(--text); font-size:13px;}
    .folderHeader .note{color:var(--muted); font-size:12px;}
    .fileList{
      max-height: 180px;
      overflow:auto;
      border:1px solid rgba(148,163,184,.12);
      border-radius: 10px;
      background: rgba(15,23,42,.35);
    }
    .fileItem{
      padding:8px 10px;
      border-bottom:1px solid rgba(148,163,184,.10);
      cursor:pointer;
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-family: var(--mono);
      font-size: 12px;
      color: var(--text);
    }
    .fileItem:hover{background: rgba(96,165,250,.06)}
    .fileItem:last-child{border-bottom:none}
    .fileMeta{color:var(--muted); font-family: var(--sans); font-size:12px; white-space:nowrap;}
    .warn{
      border:1px solid rgba(245,158,11,.25);
      background: rgba(245,158,11,.08);
      color: #fde68a;
      padding:10px 12px;
      border-radius: 12px;
      width:100%;
      font-size: 12px;
      text-align:left;
    }
    code{font-family:var(--mono)}
  
    .colorList{
      display:flex;
      flex-direction:column;
      gap:8px;
      max-height: 220px;
      overflow:auto;
      padding: 8px;
      border:1px solid rgba(148,163,184,.12);
      border-radius: 10px;
      background: rgba(15,23,42,.35);
    }
    .colorRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 8px 10px;
      border:1px solid rgba(148,163,184,.10);
      border-radius: 10px;
      background: rgba(11,16,32,.20);
    }
    .colorRow .name{
      display:flex;
      align-items:center;
      gap:10px;
      font-size: 12px;
      font-family: var(--mono);
      color: var(--text);
      flex: 1 1 auto;
      min-width: 0;
    }
    .colorRow .name span{
      white-space: normal;
      overflow-wrap: anywhere;
    }
    .dot{
      width:10px;
      height:10px;
      border-radius:999px;
      background: var(--dot, rgba(148,163,184,.55));
      box-shadow: 0 0 0 3px rgba(0,0,0,.15);
      border: 1px solid rgba(148,163,184,.18);
      flex: 0 0 auto;
    }
    .colorRow input[type="color"]{
      padding:0;
      width:40px;
      height:28px;
      border-radius: 8px;
      border:1px solid rgba(148,163,184,.22);
      background: transparent;
      cursor:pointer;
    }
    .colorRow .mini{
      font-family: var(--sans);
      font-size: 12px;
      color: var(--muted);
      white-space:nowrap;
    }

  </style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="topbar">
      <div class="title">
        <h1>Project Gorgon ‚Äî Chat Log Viewer</h1>
        <span class="sub">
  Tabs are built from the [Channel] values in your log.
  <span style="margin-left:20em">Made by Peteski Version 1.0</span>
  <br>
  Privacy: nothing is uploaded ‚Äî it runs in your browser
</span>
</div>

      <div class="controls">
        <label class="btn" for="file">üìÑ Load log file</label>
        <input id="file" type="file" accept=".log,.txt,text/plain" />
        <button class="btn" id="clear">üßπ Clear</button>
        <span class="chip"><b id="count">0</b> lines</span>
      </div>
    </div>
  </div>
</header>

<main class="wrap">
  <div class="grid">

    <section class="card">
      <header class="wrap" style="padding:12px 14px">
        <h2>Input</h2>
      </header>

      <div class="body">
        <div id="drop" class="drop">

          <div style="font-size:14px;color:var(--text)">Drop your chat log here if unable to choose folder</div>

          <div class="folderBox" id="folderBox">
            <div class="folderHeader">
              <div>
                <div class="label">Folder picker (recommended)</div>
                <div class="note" id="folderNote">Choose a folder containing your chat logs, then pick a file below.</div>
              </div>
              <div class="row" style="width:auto">
                <button class="btn" id="chooseFolder">üìÅ Choose folder</button>
                <button class="btn" id="grantAccess" title="Grant permission to access the previously selected folder" disabled>üîì Grant access</button>
                <button class="btn" id="refreshFolder" title="Re-scan the chosen folder" disabled>üîÑ Refresh</button>
              </div>
            </div>

            <div id="folderWarning" class="warn" style="display:none"></div>

            <div class="row">
              <input id="search" type="text" placeholder="Search text (filters current tab)‚Ä¶" class="grow" />
            </div>

            <div class="fileList" id="fileList" aria-label="Chat log files"></div>

            <div class="muted" id="hint" style="padding:6px 2px">Tip: newest logs are usually at the Top.</div>


            <div class="folderBox" style="padding:12px">
              <div class="folderHeader">
                <div>
                  <div class="label">Channel colours</div>
                  <div class="note">Optional: customise colours per channel (saved on this device).</div>
                </div>
                
              </div>
              <div id="colorList" class="colorList" aria-label="Channel colour pickers"></div>
            </div>


            <div class="row">
              <label class="chip"><input id="autoscroll" type="checkbox" checked /> <span>Auto-scroll</span></label>
              <label class="chip"><input id="compact" type="checkbox" /> <span>Compact view</span></label>
              
            </div>
          </div>

          <div class="muted">Fallback: load a single file via ‚ÄúLoad log file‚Äù, or paste raw log text below.</div>

          <div style="width:100%">
            <textarea id="paste" placeholder="‚Ä¶or paste raw log text here, then click Parse Paste."></textarea>
          </div>

          <div class="row" style="width:100%">
            <button class="btn" id="parsePaste">‚úÇÔ∏è Parse Paste</button>
          </div>

        </div>
      </div>
    </section>

    <section class="card">
      <div class="tabs" id="tabs"></div>
      <div class="viewer" id="viewer"></div>
      <div class="foot">
        <div class="row">
          <span class="k">Esc: <span class="sep">clear</span> search</span>
          <span class="k">Ctrl/Cmd+Enter: <span class="sep">toggle</span> Auto-scroll</span>
        </div>
        <div class="row">
          <span id="stats">No data loaded.</span>
        </div>
      </div>
    </section>

  </div>
</main>

<script>
const state = {
  all: [],
  channels: new Map(),
  activeChannel: "All",
  search: "",
  dirHandle: null,
  colorOverrides: new Map(),
};

const el = {
  file: document.getElementById("file"),
  drop: document.getElementById("drop"),
  viewer: document.getElementById("viewer"),
  tabs: document.getElementById("tabs"),
  count: document.getElementById("count"),
  stats: document.getElementById("stats"),
  search: document.getElementById("search"),
  paste: document.getElementById("paste"),
  parsePaste: document.getElementById("parsePaste"),
  clear: document.getElementById("clear"),
  autoscroll: document.getElementById("autoscroll"),
  compact: document.getElementById("compact"),
  chooseFolder: document.getElementById("chooseFolder"),
  refreshFolder: document.getElementById("refreshFolder"),
  grantAccess: document.getElementById("grantAccess"),
  fileList: document.getElementById("fileList"),
  folderWarning: document.getElementById("folderWarning"),
  folderNote: document.getElementById("folderNote"),
  colorList: document.getElementById("colorList"),
};

function normalizeChannel(ch){ return (ch||"Unparsed").trim().replace(/^\[|\]$/g, ""); }

function hslToRgb(h, s, l){
  // h:0-360, s/l:0-100
  h = (h % 360 + 360) % 360;
  s /= 100; l /= 100;
  const c = (1 - Math.abs(2*l - 1)) * s;
  const x = c * (1 - Math.abs((h/60) % 2 - 1));
  const m = l - c/2;
  let r=0,g=0,b=0;
  if(h < 60){ r=c; g=x; b=0; }
  else if(h < 120){ r=x; g=c; b=0; }
  else if(h < 180){ r=0; g=c; b=x; }
  else if(h < 240){ r=0; g=x; b=c; }
  else if(h < 300){ r=x; g=0; b=c; }
  else { r=c; g=0; b=x; }
  return [Math.round((r+m)*255), Math.round((g+m)*255), Math.round((b+m)*255)];
}

function channelColors(channelName){
  const n = (channelName || "unparsed").toLowerCase();

  // User override (stored locally)
  const ov = state.colorOverrides?.get?.(n);
  if(ov){
    const rgb = hexToRgb(ov);
    if(rgb){
      const [r,g,b] = rgb;
      return {
        text: `rgba(${r},${g},${b},0.92)`,
        border: `rgba(${r},${g},${b},0.35)`,
        bg: `rgba(${r},${g},${b},0.10)`,
        edge: `rgba(${r},${g},${b},0.78)`,
      };
    }
  }

  // Hand-picked to match the vibe of the existing UI, but every channel gets a color.
  const preset = {
    "global": [96,165,250],
    "help": [34,197,94],
    "nearby": [244,63,94],
    "status": [245,158,11],
    "guild": [168,85,247],
    "trade": [14,165,233],
    "tell": [251,146,60],
    "error": [248,113,113],
    "npc chatter": [250,204,21],
    "emotes": [45,212,191],
    "action emotes": [45,212,191],
  };

  let rgb = preset[n];
  if(!rgb){
    // Deterministic color for any other channel name
    let h = 2166136261; // FNV-ish
    for(let i=0;i<n.length;i++){
      h ^= n.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    const hue = (h >>> 0) % 360;
    rgb = hslToRgb(hue, 68, 58);
  }

  const [r,g,b] = rgb;
  return {
    text: `rgba(${r},${g},${b},0.92)`,
    border: `rgba(${r},${g},${b},0.35)`,
    bg: `rgba(${r},${g},${b},0.10)`,
    edge: `rgba(${r},${g},${b},0.78)`,
  };
}

function hexToRgb(hex){
  const h = (hex || "").trim();
  const m = h.match(/^#?([0-9a-f]{6})$/i);
  if(!m) return null;
  const n = parseInt(m[1], 16);
  return [(n >> 16) & 255, (n >> 8) & 255, n & 255];
}
function rgbToHex(r,g,b){
  const to = (x) => x.toString(16).padStart(2,"0");
  return "#" + to(r) + to(g) + to(b);
}
function loadColorOverrides(){
  try{
    const raw = localStorage.getItem("pg_channel_colors");
    if(!raw) return new Map();
    const obj = JSON.parse(raw);
    const m = new Map();
    for(const [k,v] of Object.entries(obj)){
      if(typeof v === "string") m.set(k.toLowerCase(), v);
    }
    return m;
  }catch(e){
    return new Map();
  }
}
let _previewRAF = 0;
function schedulePreview(){
  if(_previewRAF) return;
  _previewRAF = requestAnimationFrame(() => {
    _previewRAF = 0;
    // Re-rendering thousands of rows can be heavy; only live-preview for smaller logs.
    if((state.all?.length || 0) <= 2000){
      renderTabs();
      renderViewer();
    }
  });
}

function saveColorOverrides(){
  const obj = {};
  for(const [k,v] of state.colorOverrides.entries()){
    obj[k] = v;
  }
  localStorage.setItem("pg_channel_colors", JSON.stringify(obj));
}

function renderColorPickers(){
  if(!el.colorList) return;

  // Channels come from the loaded log. If none loaded yet, show a placeholder.
  const chans = [...state.channels.keys()].sort((a,b)=>a.localeCompare(b));
  if(!chans.length){
    el.colorList.innerHTML = `<div class="muted" style="padding:6px 2px">Load a log to see channels here.</div>`;
    return;
  }

  const rows = [];
  for(const ch of chans){
    const colors = channelColors(ch);
    const key = (ch || "").toLowerCase();
    const override = state.colorOverrides.get(key) || "";
    const [r,g,b] = hexToRgb(override) || [null,null,null];
    const currentHex = (r!==null) ? override : rgbToHex(
      parseInt(colors.text.match(/\d+/g)[0]),
      parseInt(colors.text.match(/\d+/g)[1]),
      parseInt(colors.text.match(/\d+/g)[2])
    );

    rows.push(`
      <div class="colorRow" style="--dot:${colors.edge}">
        <div class="name">
          <span class="dot" aria-hidden="true"></span>
          <span>${escapeHtml(ch)}</span>
        </div>
        <div class="row" style="width:auto">
          <span class="mini">${override ? "custom" : "auto"}</span>
          <input type="color" data-channel="${escapeHtml(key)}" value="${escapeHtml(currentHex)}" />
          <button class="btn" data-clear="${escapeHtml(key)}" style="padding:8px 10px">Clear</button>
        </div>
      </div>
    `);
  }

  el.colorList.innerHTML = rows.join("");

  // Wire up color inputs
  el.colorList.querySelectorAll('input[type="color"][data-channel]').forEach(inp => {
    // While dragging in the picker, keep UI responsive.
    // - For large logs: update only the picker UI (dot/label), apply on release.
    // - For small logs: we also do a throttled live preview.
    inp.addEventListener("input", () => {
      const k = inp.getAttribute("data-channel");
      const v = inp.value;
      if(k && v){
        state.colorOverrides.set(k, v);

        // Update only this row's dot + label (no rebuild)
        const row = inp.closest(".colorRow");
        if(row){
          const c = channelColors(k);
          row.style.setProperty("--dot", c.edge);
          const mini = row.querySelector(".mini");
          if(mini) mini.textContent = "custom";
        }

        // Throttled live preview (only if log isn't huge)
        schedulePreview();
      }
    });

    // Apply + save when finished (mouse-up / picker confirmed)
    inp.addEventListener("change", () => {
      const k = inp.getAttribute("data-channel");
      const v = inp.value;
      if(k && v) state.colorOverrides.set(k, v);
      saveColorOverrides();
      renderTabs();
      renderViewer();
      // Keep the picker list stable; no need to rebuild here.
    });
  });
// Wire up per-channel clear buttons
  el.colorList.querySelectorAll('button[data-clear]').forEach(btn => {
    btn.addEventListener("click", () => {
      const k = btn.getAttribute("data-clear");
      if(k){
        state.colorOverrides.delete(k);
        saveColorOverrides();
        renderTabs();
        renderViewer();
        renderColorPickers();
      }
    });
  });
}


function channelClass(ch){
  const x = (ch||"").toLowerCase();
  if(x === "status") return "status";
  if(x === "global") return "global";
  if(x === "help") return "help";
  if(x === "nearby") return "nearby";
  return "";
}
function escapeHtml(s){
  return (s ?? "").replace(/[&<>"']/g, (c) => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
  }[c]));
}

function parseLine(line){
  const m = line.match(/^(\S+\s+\S+)\s*\t\s*\[([^\]]+)\]\s*(.*)$/);
  if(!m) return { raw: line, ts: "", channel: "Unparsed", from: "", text: line.trim(), kind: "unparsed" };
  const ts = m[1];
  const channel = normalizeChannel(m[2]);
  const rest = (m[3] ?? "").trim();

  let from = "", text = rest;
  const m2 = rest.match(/^([^:]{1,40}):\s*(.*)$/);
  if(m2 && channel.toLowerCase() !== "status"){ from = m2[1].trim(); text = m2[2] ?? ""; }
  const kind = channel.toLowerCase() === "status" ? "status" : "chat";
  return { raw: line, ts, channel, from, text, kind };
}
function parseText(text){
  const lines = text.replace(/\r\n/g,"\n").split("\n").filter(l => l.trim().length > 0);
  return lines.map(parseLine);
}
function rebuildIndex(){
  state.channels = new Map();
  for(const item of state.all){
    const ch = item.channel || "Unparsed";
    if(!state.channels.has(ch)) state.channels.set(ch, []);
    state.channels.get(ch).push(item);
  }
}
function renderTabs(){
  const counts = new Map(state.channels);
  const allCount = state.all.length;
  const channelsSorted = [...counts.keys()].sort((a,b) => a.localeCompare(b));
  const tabs = ["All", ...channelsSorted];

  el.tabs.innerHTML = "";
  for(const name of tabs){
    const btn = document.createElement("div");
    btn.className = "tab" + (name === state.activeChannel ? " active" : "");
    const c = name === "All" ? allCount : (counts.get(name)?.length ?? 0);
    btn.innerHTML = `<span>${escapeHtml(name)}</span><span class="badge">${c}</span>`;
    btn.addEventListener("click", () => { state.activeChannel = name; renderTabs(); renderViewer(); });
    el.tabs.appendChild(btn);
  }
}
function activeItems(){
  let items = state.activeChannel === "All" ? state.all : (state.channels.get(state.activeChannel) ?? []);
  const q = state.search.trim().toLowerCase();
  if(q){
    items = items.filter(it =>
      (it.ts || "").toLowerCase().includes(q) ||
      (it.channel || "").toLowerCase().includes(q) ||
      (it.from || "").toLowerCase().includes(q) ||
      (it.text || "").toLowerCase().includes(q)
    );
  }
  return items;
}
function renderViewer(){
  const items = activeItems();
  const compact = el.compact.checked;
  const wantAuto = el.autoscroll.checked;
  const wasNearBottom = wantAuto && (el.viewer.scrollTop + el.viewer.clientHeight >= el.viewer.scrollHeight - 40);

  el.viewer.innerHTML = "";
  for(const it of items){
    const row = document.createElement("div");
    row.className = "msg";
    if(compact){
      row.style.gridTemplateColumns = "135px 95px 1fr";
      row.style.padding = "8px 10px";
      row.style.fontSize = "12px";
    }
    const colors = channelColors(it.channel);
    row.style.setProperty('--c', colors.text);
    row.style.setProperty('--cBorder', colors.border);
    row.style.setProperty('--cBg', colors.bg);
    row.style.setProperty('--cEdge', colors.edge);

    const pillClass = channelClass(it.channel); // kept for optional per-channel overrides
    const chanPill = `<span class="pill ${pillClass}">[${escapeHtml(it.channel)}]</span>`;
    let who = it.from ? `<span class="from">${escapeHtml(it.from)}:</span> ` : "";
    let text = escapeHtml(it.text);
    if(it.kind === "status"){ who = ""; text = `<span class="statusLine">${text}</span>`; }

    row.innerHTML = `
      <div class="ts">${escapeHtml(it.ts)}</div>
      <div class="chan">${chanPill}</div>
      <div class="text">${who}${text}</div>
    `;
    el.viewer.appendChild(row);
  }

  el.count.textContent = String(state.all.length);
  const chCount = state.channels.size;
  const showing = items.length;
  el.stats.textContent = state.all.length
    ? `Channels: ${chCount} ¬∑ Showing: ${showing} ¬∑ Active: ${state.activeChannel}${state.search ? " ¬∑ Search: ‚Äú" + state.search + "‚Äù" : ""}`
    : "No data loaded.";

  if(wasNearBottom) el.viewer.scrollTop = el.viewer.scrollHeight;
}
function loadText(text, sourceLabel=""){
  const parsed = parseText(text);
  state.all = parsed;
  rebuildIndex();
  if(state.activeChannel !== "All" && !state.channels.has(state.activeChannel)) state.activeChannel = "All";
  renderTabs();
  renderViewer();
  renderColorPickers();
  if(sourceLabel) el.folderNote.textContent = `Loaded ${parsed.length} lines from ${sourceLabel}.`;
}

/* File input / DnD / Paste */
el.file.addEventListener("change", async (e) => {
  const file = e.target.files?.[0];
  if(!file) return;
  loadText(await file.text(), file.name);
});
["dragenter","dragover"].forEach(ev => el.drop.addEventListener(ev, (e) => { e.preventDefault(); el.drop.classList.add("drag"); }));
["dragleave","drop"].forEach(ev => el.drop.addEventListener(ev, (e) => { e.preventDefault(); el.drop.classList.remove("drag"); }));
el.drop.addEventListener("drop", async (e) => {
  const file = e.dataTransfer?.files?.[0];
  if(!file) return;
  loadText(await file.text(), file.name);
});
el.parsePaste.addEventListener("click", () => {
  const t = el.paste.value || "";
  if(t.trim()) loadText(t, "pasted text");
});
el.clear.addEventListener("click", () => {
  state.all = []; state.channels = new Map(); state.activeChannel = "All"; state.search = "";
  el.search.value = ""; el.paste.value = "";
  renderTabs(); renderViewer(); renderColorPickers();
  el.folderNote.textContent = "Choose a folder containing your chat logs, then pick a file below.";
});
el.search.addEventListener("input", () => { state.search = el.search.value || ""; renderViewer(); });
window.addEventListener("keydown", (e) => {
  if(e.key === "Escape"){ state.search = ""; el.search.value = ""; renderViewer(); }
  if(e.key === "Enter" && (e.metaKey || e.ctrlKey)) el.autoscroll.checked = !el.autoscroll.checked;
});

/* Folder picker persistence (Chromium File System Access API) */
function showWarning(msg, show=true){
  el.folderWarning.style.display = show ? "block" : "none";
  el.folderWarning.innerHTML = msg ? msg : "";
}
function supportsFolderPicker(){ return !!window.showDirectoryPicker; }

const DB_NAME = "pg_chat_viewer_db", STORE = "handles", KEY = "dir";
function idbOpen(){
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if(!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}
async function idbSet(key, value){
  const db = await idbOpen();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, "readwrite");
    tx.objectStore(STORE).put(value, key);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}
async function idbGet(key){
  const db = await idbOpen();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, "readonly");
    const req = tx.objectStore(STORE).get(key);
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}
async function ensurePermission(handle, request=false){
  if(!handle) return false;
  const opts = { mode: "read" };

  // First, only *check* permission.
  if(handle.queryPermission){
    const q = await handle.queryPermission(opts);
    if(q === "granted") return true;
    // Only request permission if explicitly asked (must be user-initiated).
    if(request && handle.requestPermission){
      const r = await handle.requestPermission(opts);
      return r === "granted";
    }
    return false;
  }

  // Older implementations: best effort
  return true;
}
function looksLikeLogFile(name){
  const n = name.toLowerCase();
  return n.endsWith(".log") || n.endsWith(".txt");
}
async function listFilesInFolder(dirHandle){
  const files = [];
  for await (const [name, handle] of dirHandle.entries()){
    if(handle.kind === "file" && looksLikeLogFile(name)){
      const file = await handle.getFile();
      files.push({ name, handle, size: file.size, modified: file.lastModified ? new Date(file.lastModified) : null });
    }
  }
  files.sort((a,b) => (b.modified?.getTime()||0) - (a.modified?.getTime()||0) || a.name.localeCompare(b.name));
  return files;
}
function fmtBytes(bytes){
  if(bytes < 1024) return bytes + " B";
  const kb = bytes / 1024;
  if(kb < 1024) return kb.toFixed(1) + " KB";
  const mb = kb / 1024;
  return mb.toFixed(1) + " MB";
}
function fmtDate(d){ return d ? d.toLocaleString() : ""; }

async function renderFileList(requestPermission=false){
  el.fileList.innerHTML = "";
  if(!state.dirHandle){
    el.fileList.innerHTML = `<div class="fileItem" style="cursor:default;color:var(--muted)">No folder selected.</div>`;
    el.refreshFolder.disabled = true;
    el.grantAccess.disabled = true;
    return;
  }
  el.refreshFolder.disabled = false;

  try{
    const ok = await ensurePermission(state.dirHandle, requestPermission);
    if(!ok){
      // We can *not* request permission on page load; user must click Grant access.
      showWarning(`Folder permission is needed. Click <b>üîì Grant access</b> (or <b>Choose folder</b>) and approve the prompt.`);
      el.fileList.innerHTML = `<div class="fileItem" style="cursor:default;color:var(--muted)">Permission needed.</div>`;
      el.grantAccess.disabled = false;
      return;
    }
    el.grantAccess.disabled = true;
    showWarning("", false);
    const files = await listFilesInFolder(state.dirHandle);
    if(!files.length){
      el.fileList.innerHTML = `<div class="fileItem" style="cursor:default;color:var(--muted)">No .log or .txt files found in that folder.</div>`;
      return;
    }
    for(const f of files){
      const div = document.createElement("div");
      div.className = "fileItem";
      div.innerHTML = `<span>${escapeHtml(f.name)}</span><span class="fileMeta">${fmtBytes(f.size)} ¬∑ ${escapeHtml(fmtDate(f.modified))}</span>`;
      div.addEventListener("click", async () => {
        try{
          const file = await f.handle.getFile();
          loadText(await file.text(), f.name);
        }catch(err){
          showWarning(`Could not read that file. Error: <code>${escapeHtml(String(err))}</code>`);
        }
      });
      el.fileList.appendChild(div);
    }
  }catch(err){
    showWarning(`Folder scan failed. Error: <code>${escapeHtml(String(err))}</code>`);
  }
}

el.chooseFolder.addEventListener("click", async () => {
  if(!supportsFolderPicker()){
    showWarning(
      `Folder picking isn't available in this browser/context. Try Chrome/Edge/Brave, and ideally open this page via <code>http://localhost</code>.<br><br>
       Quick local server: <code>python -m http.server 8000</code> then open <code>http://localhost:8000</code>.`
    );
    return;
  }
  try{
    const dir = await window.showDirectoryPicker({ mode: "read" });
    state.dirHandle = dir;
    await idbSet(KEY, dir);
    showWarning("", false);
    el.folderNote.textContent = "Folder selected. Click a file to load it.";
    el.grantAccess.disabled = true;
    await renderFileList(false);
  }catch(err){
    // user cancelled is fine
  }
});
el.refreshFolder.addEventListener("click", async () => { await renderFileList(true); });

el.grantAccess.addEventListener("click", async () => {
  await renderFileList(true);
});

// Init
(async function init(){
  state.colorOverrides = loadColorOverrides();
  renderTabs(); renderViewer(); renderColorPickers();

  if(!supportsFolderPicker()){
    showWarning(`Folder picker isn't available here. You can still use <b>Load log file</b> or drag & drop.`, true);
    el.grantAccess.disabled = true;
    await renderFileList(false);
    return;
  }
  try{
    const saved = await idbGet(KEY);
    if(saved){
      state.dirHandle = saved;
      const ok = await ensurePermission(saved);
      if(ok){
        el.folderNote.textContent = "Restored previous folder. Click a file to load it.";
      }else{
        el.folderNote.textContent = "Previous folder found, but permission is needed.";
        showWarning(`Click <b>Choose folder</b> and approve permission to restore access.`, true);
      }
    }
    el.grantAccess.disabled = true;
    await renderFileList(false);
  }catch(err){
    showWarning(`Could not restore folder selection. Error: <code>${escapeHtml(String(err))}</code>`, true);
    el.grantAccess.disabled = true;
    await renderFileList(false);
  }
})();
</script>
</body>
</html>

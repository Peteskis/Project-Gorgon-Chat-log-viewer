<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Project Gorgon Live Chat Log Viewer</title>
  <style>
    :root{
      --bg:#0b1020; --panel:#0f172a; --panel2:#111c36; --text:#e5e7eb; --muted:#94a3b8;
      --border:rgba(148,163,184,.18); --accent:#60a5fa; --accent2:#22c55e; --warn:#f59e0b; --danger:#fb7185;
      --shadow: 0 12px 30px rgba(0,0,0,.35); --radius:14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:var(--sans); background:
        radial-gradient(1200px 600px at 20% 10%, rgba(96,165,250,.18), transparent 60%),
        radial-gradient(1000px 600px at 80% 10%, rgba(34,197,94,.10), transparent 60%),
        var(--bg);
      color:var(--text); line-height:1.35;
    }
    header{
      position:sticky; top:0; z-index:10;
      background: linear-gradient(180deg, rgba(11,16,32,.96), rgba(11,16,32,.86));
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--border);
    }
    .wrap{max-width:1600px;margin:0 auto;padding:18px 16px}
    .topbar{display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap;}
    .title{display:flex; gap:10px; align-items:baseline; flex-wrap:wrap;}
    .title h1{margin:0;font-size:18px;letter-spacing:.2px}
    .title .sub{color:var(--muted);font-size:13px}
    .controls{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .btn, .chip, input[type="text"], textarea, select{
      border:1px solid var(--border);
      background: rgba(15,23,42,.65);
      color:var(--text);
      border-radius:12px;
      padding:10px 12px;
      font-size:13px;
      outline:none;
    }

    .btn{cursor:pointer; transition: transform .06s ease, border-color .2s ease, background .2s ease; user-select:none;}
    .btn:hover{border-color: rgba(96,165,250,.55); background: rgba(15,23,42,.88)}
    .btn:active{transform: translateY(1px)}
    #ttsPlay.playing{border-color: rgba(34,197,94,.75); background: rgba(34,197,94,.18); box-shadow: 0 0 0 2px rgba(34,197,94,.12) inset;}
    input[type="file"]{display:none}
    .chip{padding:8px 10px; display:inline-flex; gap:8px; align-items:center;}
    .chip b{font-weight:600}
    .grid{display:grid; grid-template-columns: 1fr; gap:14px; margin-top:14px;}
    @media(min-width:960px){ .grid{grid-template-columns: 540px 1fr} }
    .card{
      background: linear-gradient(180deg, rgba(15,23,42,.85), rgba(15,23,42,.65));
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card header{position:unset; background:none; border-bottom:1px solid var(--border);}
    .card h2{margin:0; font-size:13px; letter-spacing:.3px; text-transform:uppercase; color:var(--muted);}
    .card .body{padding:14px}
    .drop{
      border: 1px dashed rgba(148,163,184,.35);
      background: rgba(17,28,54,.35);
      border-radius: 12px;
      padding: 14px;
      color: var(--muted);
      font-size: 13px;
      display:flex; flex-direction:column; gap:10px;
      min-height: 160px; justify-content:center; align-items:center; text-align:center;
    }
    .drop.drag{border-color: rgba(96,165,250,.8); background: rgba(96,165,250,.08); color: var(--text)}
    textarea{width:100%; min-height: 120px; resize: vertical; font-family: var(--mono); background: rgba(11,16,32,.35);}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap; width:100%;}
    .row .grow{flex:1}
    .muted{color:var(--muted)}
    .tabs{display:flex; gap:8px; flex-wrap:wrap; padding:12px; border-bottom:1px solid var(--border); background: rgba(17,28,54,.25);}
    .tab{
      border:1px solid var(--border); background: rgba(15,23,42,.55);
      padding:8px 10px; border-radius: 999px; font-size: 13px; cursor:pointer;
      display:inline-flex; align-items:center; gap:8px; user-select:none;
      transition: border-color .2s ease, background .2s ease;
    }
    .tab:hover{border-color: rgba(96,165,250,.55)}
    .tab.active{border-color: rgba(96,165,250,.9); background: rgba(96,165,250,.14);}
    .badge{font-size:12px; padding:2px 8px; border-radius: 999px; border: 1px solid var(--border); color: var(--muted);}
    .badge.new{color: rgba(226,232,240,.95); border-color: rgba(34,197,94,.55); background: rgba(34,197,94,.14);}
    .tab.unread{border-color: rgba(34,197,94,.70); background: rgba(34,197,94,.10);}
    .viewer{height: var(--viewerHeight, calc(100vh - 240px)); min-height: 320px; max-height: calc(100vh - 140px); overflow:auto; background: rgba(11,16,32,.25);}

    .viewerWrap{position:relative}
    .tutorialOverlay{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      padding:18px;
      background: linear-gradient(180deg, rgba(11,16,32,.55), rgba(11,16,32,.25));
      pointer-events:none;
    }
    .tutorialCard{
      width:min(760px, 100%);
      background: rgba(15,23,42,.92);
      border:1px solid var(--border);
      border-radius:16px;
      box-shadow: var(--shadow);
      padding:16px 16px 14px;
      pointer-events:auto;
    }
    .tutorialHead{display:flex; align-items:flex-start; justify-content:space-between; gap:10px; margin-bottom:10px}
    .tutorialTitle{margin:0; font-size:16px; letter-spacing:.2px}
    .tutorialClose{cursor:pointer; border:1px solid var(--border); background: rgba(15,23,42,.55); color:var(--text); border-radius:12px; padding:6px 10px; line-height:1}
    .tutorialGrid{display:grid; grid-template-columns: 1.2fr 1fr; gap:12px}
    @media (max-width: 980px){ .tutorialGrid{grid-template-columns:1fr} }
    .tutorialBlock{
      background: rgba(17,28,54,.55);
      border:1px solid rgba(148,163,184,.12);
      border-radius:14px;
      padding:12px;
    }
    .tutorialBlock h3{margin:0 0 8px 0; font-size:13px; color:var(--text)}
    .tutorialBlock ul{margin:0; padding-left:18px; color:var(--muted); font-size:13px}
    .tutorialBlock li{margin:6px 0}
    .tutorialKbd{font-family:var(--mono); font-size:12px; color:var(--text); background: rgba(96,165,250,.14); border:1px solid rgba(96,165,250,.22); padding:1px 6px; border-radius:8px}
    .tutorialActions{display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap; margin-top:12px}
    .btn.small{padding:8px 10px; border-radius:12px}
    .btn.ghost{background: rgba(15,23,42,.35)}


    /* Performance mode: virtualized rows (fixed height + ellipsis) */
    .viewer.perf .msg{
      height: var(--rowH, 32px);
      padding: 6px 10px;
      overflow:hidden;
      align-items:center;
    }
    .viewer.perf .text{
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .viewer.perf .ts, .viewer.perf .chan{
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    
    .perfPreview{
      border-top:1px solid rgba(148,163,184,.18);
      background: rgba(15,23,42,.72);
      backdrop-filter: blur(6px);
      padding: 8px 10px;
      display:flex;
      gap:10px;
      align-items:flex-start;
      position: relative;
      min-height: 42px;
    }
    .perfPreviewHint{
      color: rgba(226,232,240,.85);
      font-size: 12px;
      white-space: nowrap;
      flex: 0 0 auto;
      align-self: center;
    }
    .perfPreviewBody{
      color: rgba(241,245,249,.95);
      font-size: 13px;
      line-height: 1.25rem;
      white-space: pre-wrap;
      word-break: break-word;
      flex: 1 1 auto;
      max-height: 140px;
      overflow: auto;
      padding-right: 28px;
    }
    .perfPreviewClose{
      position:absolute;
      right: 8px;
      top: 6px;
      width: 24px;
      height: 24px;
      border-radius: 8px;
      border: 1px solid rgba(148,163,184,.25);
      background: rgba(2,6,23,.35);
      color: rgba(241,245,249,.9);
      cursor:pointer;
    }
    .perfPreviewClose:hover{ background: rgba(2,6,23,.55); }

    .v-resize{height:10px; cursor:row-resize; background: rgba(148,163,184,.06); border-top:1px solid rgba(148,163,184,.18); border-bottom:1px solid rgba(148,163,184,.12);}
    .v-resize:hover{background: rgba(96,165,250,.10);}
    .v-resize:active{background: rgba(96,165,250,.16);}

    .msg{
      display:grid; grid-template-columns: 170px 130px 1fr; gap:10px;
      border-left: 4px solid var(--cEdge, transparent);
      padding:10px 12px; border-bottom:1px solid rgba(148,163,184,.10);
      font-family: var(--mono); font-size: 13px; line-height:1.35;
    }
    .msg:hover{background: rgba(96,165,250,.06)}

    /* TTS phrase highlight */
    .msg.tts-speaker{
      background: rgba(245,158,11,.08);
      box-shadow: inset 0 0 0 1px rgba(245,158,11,.22);
    }
    .msg.tts-hit{
      background: rgba(245,158,11,.14);
      box-shadow: inset 0 0 0 2px rgba(245,158,11,.35);
    }

    /* Alert rules UI */
    .rulesList{display:flex; flex-direction:column; gap:8px; margin-top:10px;}
    .ruleItem{border:1px solid rgba(148,163,184,.16); background: rgba(15,23,42,.32); border-radius:12px; padding:10px 10px; display:flex; gap:10px; align-items:flex-start; justify-content:space-between;}
    .ruleMain{display:flex; gap:10px; align-items:flex-start; flex:1; min-width:0;}
    .ruleMain input[type="checkbox"]{transform: translateY(2px);}
    .ruleText{min-width:0;}
    .ruleName{font-weight:700; font-size:13px; color:var(--text);}
    .ruleDesc{font-size:12px; color:var(--muted); margin-top:2px; word-break:break-word;}
    .ruleBtns{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;}
    .miniBtn{padding:8px 10px; border-radius:10px; font-size:12px;}
    .fieldGrid{display:grid; grid-template-columns:1fr; gap:10px; margin-top:10px;}
    @media(min-width:960px){ .fieldGrid{grid-template-columns:1fr 1fr;} }
    .fieldGrid .full{grid-column:1 / -1;}
    .smallInput{padding:8px 10px; border-radius:10px;}
    .ts{color: var(--muted)}
    .chan{display:inline-flex; align-items:center; gap:8px; white-space:nowrap;}
    .pill{
      display:inline-flex; align-items:center; border-radius: 999px;
      padding:2px 8px;
      border:1px solid var(--cBorder, rgba(148,163,184,.22));
      background: var(--cBg, rgba(15,23,42,.6));
      color: var(--text);
      font-size: 12px;
    }
    .pill.status{border-color: rgba(245,158,11,.35); background: rgba(245,158,11,.10)}
    .pill.global{border-color: rgba(96,165,250,.35); background: rgba(96,165,250,.10)}
    .pill.help{border-color: rgba(34,197,94,.35); background: rgba(34,197,94,.10)}
    .pill.nearby{border-color: rgba(244,63,94,.30); background: rgba(244,63,94,.10)}
    .from{color: var(--c, #cbd5e1); font-weight:600}
    .text{white-space:pre-wrap; word-break:break-word; color: var(--c, var(--text))}
    .statusLine{color: #fcd34d}
    .foot{
      padding:10px 12px; display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap;
      border-top:1px solid var(--border); background: rgba(17,28,54,.25); color: var(--muted); font-size: 12px;
    }
    .k{display:inline-flex; gap:6px; align-items:center; padding: 6px 10px; border-radius: 999px;
      border:1px solid rgba(148,163,184,.20); background: rgba(15,23,42,.45); color: var(--muted); font-family: var(--mono); font-size: 12px;}
    .sep{opacity:.35}

    .folderBox{
      width:100%;
      border:1px solid rgba(148,163,184,.20);
      background: rgba(11,16,32,.20);
      border-radius: 12px;
      padding: 12px;
      display:flex;
      flex-direction:column;
      gap:10px;
      text-align:left;
    }
    /* Pastel section backgrounds */
    #folderBox{background: rgba(96,165,250,.10); border-color: rgba(96,165,250,.28);}
    #channelColorsBox{background: rgba(34,197,94,.10); border-color: rgba(34,197,94,.26);}
    #ttsBox{background: rgba(168,85,247,.10); border-color: rgba(168,85,247,.26);}
    #alertsBox{background: rgba(245,158,11,.10); border-color: rgba(245,158,11,.28);}
    #folderBox .folderHeader .label,
    #channelColorsBox .folderHeader .label,
    #ttsBox .folderHeader .label,
    #alertsBox .folderHeader .label{font-size:16px;}
    
    .folderHeader{display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;; padding-bottom:6px; border-bottom:1px solid rgba(148,163,184,.18);}
    .folderHeader .label{color:var(--text); font-size:15px; font-weight:700; letter-spacing:.2px;}
    .folderHeader .note{color:var(--muted); font-size:12px;}
    .fileList{
      max-height: 180px;
      overflow:auto;
      border:1px solid rgba(148,163,184,.12);
      border-radius: 10px;
      background: rgba(15,23,42,.35);
    }
    .fileItem{
      padding:8px 10px;
      border-bottom:1px solid rgba(148,163,184,.10);
      cursor:pointer;
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-family: var(--mono);
      font-size: 12px;
      color: var(--text);
    }
    .fileItem:hover{background: rgba(96,165,250,.06)}
    .fileItem:last-child{border-bottom:none}
    .fileMeta{color:var(--muted); font-family: var(--sans); font-size:12px; white-space:nowrap;}
    .warn{
      border:1px solid rgba(245,158,11,.25);
      background: rgba(245,158,11,.08);
      color: #fde68a;
      padding:10px 12px;
      border-radius: 12px;
      width:100%;
      font-size: 12px;
      text-align:left;
    }
    code{font-family:var(--mono)}
  
    .colorList{
      display:flex;
      flex-direction:column;
      gap:8px;
      max-height: 220px;
      overflow:auto;
      padding: 8px;
      border:1px solid rgba(148,163,184,.12);
      border-radius: 10px;
      background: rgba(15,23,42,.35);
    }
    .colorRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 8px 10px;
      border:1px solid rgba(148,163,184,.10);
      border-radius: 10px;
      background: rgba(11,16,32,.20);
    }
    .colorRow .name{
      display:flex;
      align-items:center;
      gap:10px;
      font-size: 12px;
      font-family: var(--mono);
      color: var(--text);
    }
    .dot{
      width:10px;
      height:10px;
      border-radius:999px;
      background: var(--dot, rgba(148,163,184,.55));
      box-shadow: 0 0 0 3px rgba(0,0,0,.15);
      border: 1px solid rgba(148,163,184,.18);
      flex: 0 0 auto;
    }
    .colorRow input[type="color"]{
      padding:0;
      width:40px;
      height:28px;
      border-radius: 8px;
      border:1px solid rgba(148,163,184,.22);
      background: transparent;
      cursor:pointer;
    }
    .colorRow .mini{
      font-family: var(--sans);
      font-size: 12px;
      color: var(--muted);
      white-space:nowrap;
    }

  
    .subwrap{display:flex; flex-direction:column; gap:2px; min-width:0;}
    .subrow{display:flex; align-items:baseline; gap:12px; min-width:0;}
    .subrow .sub{flex: 1 1 auto; min-width:0; padding-right:64px;}
    .madeby{color:var(--muted); font-size:13px; white-space:nowrap; margin-left:auto; padding-left:56px;}
    .sub.privacy{color:var(--muted); font-size:12px;}

  
    .btnRow{display:flex; gap:10px; flex-wrap:nowrap; align-items:center;}

    /* Collapsible section toggles (minimize/expand) */
    .secToggle{
      border:1px solid var(--border);
      background:rgba(15,23,42,.35);
      color:var(--text);
      padding:6px 10px;
      border-radius:10px;
      cursor:pointer;
      font-weight:800;
      line-height:1;
      user-select:none;
    }
    .secToggle:hover{filter:brightness(1.08);}
    .secToggle:active{transform:translateY(1px);}
    .secBody{margin-top:10px;}
    .secBody.isCollapsed{display:none;}


    /* Independent scrollbar for the whole Input panel (left side) */
    @media(min-width:960px){
      .inputCard{max-height: calc(100vh - 120px); display:flex; flex-direction:column;}
      .inputCard > header{flex:0 0 auto;}
      .inputCard .body{flex:1 1 auto; overflow:auto;}
    }

  </style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="topbar">
      <div class="title">
        <h1>Project Gorgon ‚Äî Live Chat Log Viewer</h1>
        <div class="subwrap">
  <div class="subrow">
    <span class="sub">Tabs are built from the [Channel] values in your log.</span>
    <span class="madeby">Made by Peteski V1.3</span>
  </div>
  <div class="sub privacy">Privacy: nothing is uploaded ‚Äî it runs in your browser</div>
</div>
      </div>

      <div class="controls">
<label class="btn" for="file">üìÑ Load log file</label>
        <input id="file" type="file" accept=".log,.txt,text/plain" />
        <button class="btn" id="clear">üßπ Clear</button>
        <button class="btn" id="tutorialBtn" title="Show a quick tutorial">‚ùî Tutorial</button>
        <span class="chip"><b id="count">0</b> lines</span>
      </div>
    </div>
  </div>
</header>

<main class="wrap">
  <div class="grid">

    <section class="card inputCard">
      <header class="wrap" style="padding:12px 14px">
        <h2>Input</h2>
      </header>

      <div class="body">
        <div id="drop" class="drop">

          <div style="font-size:14px;color:var(--text)">Drop your chat log here</div>

          <div class="folderBox" id="folderBox">
            <div class="folderHeader">
              <div>
                <div class="label">Folder picker (recommended)</div>
                <div class="note" id="folderNote">Choose a folder containing your chat logs, then pick a file below.</div>
              </div>
              <div class="btnRow">
                <button class="btn" id="chooseFolder">üìÅ Choose folder</button>
                <button class="btn" id="grantAccess" title="Grant permission to access the previously selected folder" disabled>üîì Grant access</button>
                <button class="btn" id="refreshFolder" title="Re-scan the chosen folder" disabled>üîÑ Refresh</button>
                <button class="secToggle" id="toggle_folderBox" data-sec="folderBox" type="button" title="Collapse/expand this section">‚ñæ</button>
              </div>
            </div>

            <div class="secBody" data-sec-body="folderBox">

            <div id="browserNote" class="warn" style="display:none"></div>

            <div id="folderWarning" class="warn" style="display:none"></div>
            <div class="fileList" id="fileList" aria-label="Chat log files"></div>

            <div class="muted" id="hint" style="padding:6px 2px">Tip: Newest logs are usually at the Top.</div>

            <div class="row">
              <input id="search" type="text" placeholder="Search text (filters current tab)‚Ä¶" class="grow" />
            </div>

            <div class="folderBox" style="padding:12px" id="channelColorsBox">
              <div class="folderHeader">
                <div>
                  <div class="label">Channel colours</div>
                  <div class="note">Optional: customise colours per channel (saved on this device).</div>
                </div>
                <div>
                  <button class="secToggle" id="toggle_channelColorsBox" data-sec="channelColorsBox" type="button" title="Collapse/expand this section">‚ñ∏</button>
                </div>
              </div>
              <div class="secBody" data-sec-body="channelColorsBox">
                <div id="colorList" class="colorList" aria-label="Channel colour pickers"></div>
              </div>
            </div>            <div class="folderBox" style="padding:12px" id="ttsBox">
              <div class="folderHeader">
                <div>
                  <div class="label">Read aloud (text-to-speech)</div>
                  <div class="note">Speak message text after the speaker name (detected as <code>Name:</code>) from a channel and/or speaker.</div>
                </div>
                <div>
                  <button class="secToggle" id="toggle_ttsBox" data-sec="ttsBox" type="button" title="Collapse/expand this section">‚ñ∏</button>
                </div>
              </div>
              <div class="secBody" data-sec-body="ttsBox">
<div class="row">
                <input id="ttsChannel" type="text" placeholder="Channel(s) (comma-separated, e.g. Global, Help, Guild)" class="grow" />
              </div>

              <div class="row">
                <input id="ttsSpeaker" type="text" placeholder="Speaker (e.g. Zewtastic or Zewtastic:)" class="grow" />
              </div>


              <div class="row">
                <input id="ttsPhrase" type="text" placeholder="Trigger phrase (e.g. egg run)" class="grow" />
              </div>

              <div class="muted" style="font-size:12px; padding:2px 2px 6px">
                Tip: Leave boxes blank to read everything in the selected scope.
              </div>

              <div class="row">
                <label class="chip" title="When enabled, Play will start from the bottom and only read NEW matching messages as they arrive (live).">
                  <input id="ttsLive" type="checkbox" checked />
                  <span>Live (from now)</span>
                </label>
              </div>
              <div class="row">
                <label class="chip" title="Where to search for messages">
                  <span>Scope</span>
                  <select id="ttsScope" style="padding:8px 10px">
                    <option value="tab" selected>Current tab</option>
                    <option value="all">All channels</option>
                  </select>
                </label>
                <label class="chip" title="Include the [Channel] in what is spoken">
                  <input id="ttsSayChannel" type="checkbox" />
                  <span>Say channel</span>
                </label>
              </div>

              <div class="row">
                <label class="chip" title="Voice used by your browser">
                  <span>Voice</span>
                  <select id="ttsVoice" style="padding:8px 10px; max-width: 280px"></select>
                </label>
                <label class="chip" title="Speaking speed">
                  <span>Speed</span>
                  <select id="ttsRate" style="padding:8px 10px">
                    <option value="0.8">0.8√ó</option>
                    <option value="0.9">0.9√ó</option>
                    <option value="1" selected>1.0√ó</option>
                    <option value="1.1">1.1√ó</option>
                    <option value="1.25">1.25√ó</option>
                    <option value="1.4">1.4√ó</option>
                  </select>
                </label>
              </div>

              <div class="row">
                <button class="btn" id="ttsPlay">üîä Play</button>
                <button class="btn" id="ttsTest" title="Speak a short test phrase to confirm your browser audio/voice works">üß™ Test</button>
                <button class="btn" id="ttsPause" disabled>‚è∏ Pause</button>
                <button class="btn" id="ttsStop" disabled>‚èπ Stop</button>
                <span class="muted" id="ttsStatus" style="font-size:13px; opacity:.95"></span>
              </div>

              </div>
            </div>

            <div class="folderBox" style="padding:12px" id="alertsBox">
              <div class="folderHeader">
                <div>
                  <div class="label">Alert rules</div>
                  <div class="note">Create multiple rules that can speak and/or highlight when new messages match (works with live auto-refresh).</div>
                </div>
              <div>
                  <button class="secToggle" id="toggle_alertsBox" data-sec="alertsBox" type="button" title="Collapse/expand this section">‚ñ∏</button>
                </div>
              </div>

              <div class="secBody" data-sec-body="alertsBox">

              <div class="row">
                <label class="chip" title="Enable your saved alert rules">
                  <input id="alertsEnabled" type="checkbox" />
                  <span>Enable alerts</span>
                </label>
                <button class="btn" id="alertsArm" title="Start listening from the bottom (ignore older lines)">‚è± Arm from now</button>
                <span class="muted" id="alertsStatus" style="font-size:13px; opacity:.95"></span>
              
              <div class="mentionBox" style="margin-top:10px; padding:10px; border:1px solid var(--border); border-radius:12px; background: rgba(15,23,42,.45);">
                <div class="row" style="justify-content:space-between; align-items:center;">
                  <div>
                    <div class="label">Mentions / My name</div>
                    <div class="note">Speak/highlight when someone mentions your name(s) in chat (checks new messages during live updates).</div>
                  </div>
                  <label class="chip" title="Enable mention alerts">
                    <input id="mentionsEnabled" type="checkbox" />
                    <span>Enable mentions</span>
                  </label>
                </div>

                <div class="fieldGrid" style="margin-top:8px">
                  <div class="full">
                    <input id="mentionsNames" type="text" class="grow smallInput" placeholder="Names (comma-separated, e.g. Zewtastic, Peteski)" />
                  </div>

                  <label class="chip" title="Where mention alerts apply">
                    <span>Scope</span>
                    <select id="mentionsScope" style="padding:8px 10px">
                      <option value="tab">Current tab</option>
                      <option value="all" selected>All channels</option>
                    </select>
                  </label>

                  <label class="chip" title="Speak the message when a mention is detected">
                    <input id="mentionsSpeak" type="checkbox" checked />
                    <span>Speak</span>
                  </label>
                  <label class="chip" title="Highlight all messages from the speaker who mentioned you">
                    <input id="mentionsHiSpeaker" type="checkbox" checked />
                    <span>Highlight speaker</span>
                  </label>
                  <label class="chip" title="Highlight the line where your name was mentioned">
                    <input id="mentionsHiLine" type="checkbox" checked />
                    <span>Highlight line</span>
                  </label>

                  <div>
                    <input id="mentionsDuration" type="text" class="grow smallInput" placeholder="Highlight seconds (e.g. 20)" value="20" />
                  </div>
                  <div>
                    <input id="mentionsCooldown" type="text" class="grow smallInput" placeholder="Cooldown seconds (e.g. 2)" value="2" />
                  </div>

                  <div class="full row" style="margin-top:4px">
                    <button class="btn" id="mentionsSave">üíæ Save mentions</button>
                    <span class="muted" id="mentionsStatus" style="font-size:12px"></span>
                  </div>
                </div>
              </div>

</div>

              <div id="rulesList" class="rulesList" aria-label="Alert rules"></div>

              <div class="row" style="margin-top:8px">
                <button class="btn" id="addRule">‚ûï Add rule</button>
              </div>

              <div id="ruleEditor" style="display:none; margin-top:10px">
                <div class="fieldGrid">
                  <div class="full">
                    <input id="ruleName" type="text" class="grow smallInput" placeholder="Rule name (e.g. Egg runs)" />
                  </div>

                  <label class="chip" title="Enable/disable this rule">
                    <input id="ruleEnabled" type="checkbox" checked />
                    <span>Enabled</span>
                  </label>

                  <label class="chip" title="Where this rule applies">
                    <span>Scope</span>
                    <select id="ruleScope" style="padding:8px 10px">
                      <option value="tab">Current tab</option>
                      <option value="all" selected>All channels</option>
                    </select>
                  </label>

                  <div>
                    <input id="ruleChannel" type="text" class="grow smallInput" placeholder="Channel(s), comma-separated (blank = any)" />
                  </div>
                  <div>
                    <input id="ruleSpeaker" type="text" class="grow smallInput" placeholder="Speaker (blank = any)" />
                  </div>
                  <div class="full">
                    <input id="rulePhrase" type="text" class="grow smallInput" placeholder="Phrase (blank = any, e.g. egg run)" />
                  </div>

                  <div class="full row">
                    <label class="chip" title="Speak the message text when matched">
                      <input id="ruleActSpeak" type="checkbox" checked />
                      <span>Speak</span>
                    </label>
                    <label class="chip" title="Highlight all messages from the matched speaker">
                      <input id="ruleActHiSpeaker" type="checkbox" checked />
                      <span>Highlight speaker</span>
                    </label>
                    <label class="chip" title="Highlight the triggering line">
                      <input id="ruleActHiLine" type="checkbox" checked />
                      <span>Highlight line</span>
                    </label>
                    <label class="chip" title="Play a custom sound when matched (instead of or in addition to speaking)">
                      <input id="ruleActSound" type="checkbox" />
                      <span>Play sound</span>
                    </label>
                  </div>
                  <div class="full row" id="ruleSoundRow" style="margin-top:6px; display:none; gap:8px; flex-wrap:wrap">
                    <button class="btn" id="ruleSoundChoose" type="button">üéµ Choose sound</button>
                    <button class="btn" id="ruleSoundClear" type="button" title="Remove the saved sound for this rule">üßπ Clear</button>
                    <span class="muted" id="ruleSoundLabel" style="font-size:12px">No sound selected</span>
                    <input id="ruleSoundFile" type="file" accept="audio/*" style="display:none" />
                  </div>


                  <div>
                    <input id="ruleDuration" type="text" class="grow smallInput" placeholder="Highlight seconds (e.g. 20)" value="20" />
                  </div>
                  <div>
                    <input id="ruleCooldown" type="text" class="grow smallInput" placeholder="Cooldown seconds (e.g. 2)" value="2" />
                  </div>

                  <div class="full row" style="margin-top:4px">
                    <button class="btn" id="ruleSave">üíæ Save rule</button>
                    <button class="btn" id="ruleCancel">‚úñ Cancel</button>
                  </div>

                  <div class="full muted" style="font-size:12px">
                    Notes: rules only evaluate NEW lines as they arrive. Leave fields blank to match anything.
                  </div>
                </div>
              </div>
              </div>
            </div>






            <div class="row">
              <label class="chip"><input id="autoscroll" type="checkbox" checked /> <span>Auto-scroll</span></label>
              <label class="chip"><input id="compact" type="checkbox" /> <span>Compact view</span></label>
              <label class="chip" title="Performance mode uses virtualized rendering for huge logs (keeps full history)"><input id="performance" type="checkbox" /> <span>Performance mode</span></label>
              <label class="chip"><input id="autoRefresh" type="checkbox" checked /> <span>Auto-refresh</span></label>
              <label class="chip" title="How often to check the log file for new lines">
                <span>Every</span>
                <select id="refreshInterval" style="padding:8px 10px">
                  <option value="1000" selected>1s</option>
                  <option value="2000">2s</option>
                  <option value="5000">5s</option>
                  <option value="10000">10s</option>
                  <option value="30000">30s</option>
                </select>
              </label>
              
            </div>

            </div><!-- /secBody folderBox -->
          </div>

          <div class="muted">Fallback: load a single file via ‚ÄúLoad log file‚Äù, or paste raw log text below.</div>

          <div style="width:100%">
            <textarea id="paste" placeholder="‚Ä¶or paste raw log text here, then click Parse Paste."></textarea>
          </div>

          <div class="row" style="width:100%">
            <button class="btn" id="parsePaste">‚úÇÔ∏è Parse Paste</button>
          </div>

        </div>
      </div>
    </section>

    <section class="card">
      <div class="tabs" id="tabs"></div>
      <div class="viewerWrap" id="viewerWrap">
        <div class="viewer" id="viewer"></div>
        <div id="tutorialOverlay" class="tutorialOverlay" style="display:none"></div>
      </div>
      <div id="viewerResize" class="v-resize" title="Drag to resize the chat window"></div>
      <div id="perfPreview" class="perfPreview" style="display:none;">
        <div class="perfPreviewHint" id="perfPreviewHint">Performance mode: click a message to view the full text.</div>
        <div class="perfPreviewBody" id="perfPreviewBody"></div>
        <button class="perfPreviewClose" id="perfPreviewClose" title="Close">√ó</button>
      </div>
      <div class="foot">
        <div class="row">
          <span class="k">Esc: <span class="sep">clear</span> search</span>
          <span class="k">Ctrl/Cmd+Enter: <span class="sep">toggle</span> Auto-scroll</span>
        </div>
        <div class="row">
          <span id="stats">No data loaded.</span>
        </div>
      </div>
    </section>

  </div>
</main>

<script>
const state = {
  all: [],
  channels: new Map(),
  unreadCounts: new Map(),
  activeChannel: "All",
  search: "",
  dirHandle: null,
  colorOverrides: new Map(),
  currentFileHandle: null,
  currentFileName: "",
  currentFileSize: 0,
  tailRemainder: "",
  refreshTimer: null,
  nextId: 0,
  // TTS/alerts highlight state (used by performance mode too)
  ttsHiSpeakerKey: "",
  ttsHiItemId: null,
  ttsHiUntil: 0,

  // Tutorial overlay state
  tutorialOverride: null, // null=auto, true=force show, false=force hide
  tutorialDismissed: false,
};

const el = {
  file: document.getElementById("file"),
  drop: document.getElementById("drop"),
  viewer: document.getElementById("viewer"),
  viewerResize: document.getElementById("viewerResize"),
  perfPreview: document.getElementById("perfPreview"),
  perfPreviewBody: document.getElementById("perfPreviewBody"),
  perfPreviewHint: document.getElementById("perfPreviewHint"),
  perfPreviewClose: document.getElementById("perfPreviewClose"),
  tabs: document.getElementById("tabs"),
  count: document.getElementById("count"),
  stats: document.getElementById("stats"),
  tutorialBtn: document.getElementById("tutorialBtn"),
  tutorialOverlay: document.getElementById("tutorialOverlay"),
  search: document.getElementById("search"),
  paste: document.getElementById("paste"),
  parsePaste: document.getElementById("parsePaste"),
  clear: document.getElementById("clear"),
  autoscroll: document.getElementById("autoscroll"),
  compact: document.getElementById("compact"),
  performance: document.getElementById("performance"),
  autoRefresh: document.getElementById("autoRefresh"),
  refreshInterval: document.getElementById("refreshInterval"),
  chooseFolder: document.getElementById("chooseFolder"),
  refreshFolder: document.getElementById("refreshFolder"),
  grantAccess: document.getElementById("grantAccess"),
  fileList: document.getElementById("fileList"),
  browserNote: document.getElementById("browserNote"),
  folderWarning: document.getElementById("folderWarning"),
  folderNote: document.getElementById("folderNote"),
  colorList: document.getElementById("colorList"),
  // Text-to-speech (read aloud)
  ttsChannel: document.getElementById("ttsChannel"),
  ttsSpeaker: document.getElementById("ttsSpeaker"),
  ttsPhrase: document.getElementById("ttsPhrase"),
  ttsLive: document.getElementById("ttsLive"),
  ttsScope: document.getElementById("ttsScope"),
  ttsSayChannel: document.getElementById("ttsSayChannel"),
  ttsVoice: document.getElementById("ttsVoice"),
  ttsRate: document.getElementById("ttsRate"),
  ttsPlay: document.getElementById("ttsPlay"),
  ttsTest: document.getElementById("ttsTest"),
  ttsPause: document.getElementById("ttsPause"),
  ttsStop: document.getElementById("ttsStop"),
  ttsStatus: document.getElementById("ttsStatus"),

  // Alert rules
  alertsBox: document.getElementById("alertsBox"),

  mentionsEnabled: document.getElementById("mentionsEnabled"),
  mentionsNames: document.getElementById("mentionsNames"),
  mentionsScope: document.getElementById("mentionsScope"),
  mentionsSpeak: document.getElementById("mentionsSpeak"),
  mentionsHiSpeaker: document.getElementById("mentionsHiSpeaker"),
  mentionsHiLine: document.getElementById("mentionsHiLine"),
  mentionsDuration: document.getElementById("mentionsDuration"),
  mentionsCooldown: document.getElementById("mentionsCooldown"),
  mentionsSave: document.getElementById("mentionsSave"),
  mentionsStatus: document.getElementById("mentionsStatus"),
  alertsEnabled: document.getElementById("alertsEnabled"),
  alertsArm: document.getElementById("alertsArm"),
  alertsStatus: document.getElementById("alertsStatus"),
  rulesList: document.getElementById("rulesList"),
  addRule: document.getElementById("addRule"),
  ruleEditor: document.getElementById("ruleEditor"),
  ruleName: document.getElementById("ruleName"),
  ruleEnabled: document.getElementById("ruleEnabled"),
  ruleScope: document.getElementById("ruleScope"),
  ruleChannel: document.getElementById("ruleChannel"),
  ruleSpeaker: document.getElementById("ruleSpeaker"),
  rulePhrase: document.getElementById("rulePhrase"),
  ruleActSpeak: document.getElementById("ruleActSpeak"),
  ruleActHiSpeaker: document.getElementById("ruleActHiSpeaker"),
  ruleActHiLine: document.getElementById("ruleActHiLine"),
  ruleActSound: document.getElementById("ruleActSound"),
  ruleSoundRow: document.getElementById("ruleSoundRow"),
  ruleSoundChoose: document.getElementById("ruleSoundChoose"),
  ruleSoundClear: document.getElementById("ruleSoundClear"),
  ruleSoundLabel: document.getElementById("ruleSoundLabel"),
  ruleSoundFile: document.getElementById("ruleSoundFile"),
  ruleDuration: document.getElementById("ruleDuration"),
  ruleCooldown: document.getElementById("ruleCooldown"),
  ruleSave: document.getElementById("ruleSave"),
  ruleCancel: document.getElementById("ruleCancel"),
};


(function initBrowserNote(){
  // Firefox (and some other browsers) don't support the File System Access API used for folder mode + live refresh.
  const isFirefox = /firefox/i.test(navigator.userAgent);
  const supportsFSAccess = ("showDirectoryPicker" in window) && ("FileSystemFileHandle" in window);

  if(!el.browserNote) return;
  if(isFirefox || !supportsFSAccess){
    el.browserNote.style.display = "block";
    el.browserNote.innerHTML =
      "‚ö†Ô∏è <b>Browser note:</b> Folder picker + live auto-refresh use the File System Access API, which isn't available in Firefox. " +
      "You can still <b>drag & drop</b> or <b>Load log file</b>, but for live updating use <b>Chrome</b>, <b>Edge</b>, or <b>Opera</b>.";
  }
})();


// -----------------------------
// Viewer vertical resize (drag handle)
// -----------------------------
(function initViewerResize(){
  if(!el.viewer || !el.viewerResize) return;

  const KEY = "pg_viewer_height";
  const root = document.documentElement;

  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

  function applyHeight(px, persist=true){
    const minH = 220;
    const maxH = Math.max(minH, window.innerHeight - 180);
    const h = Math.round(clamp(px, minH, maxH));
    root.style.setProperty("--viewerHeight", h + "px");
    if(persist) localStorage.setItem(KEY, String(h));
  }

  // Load saved height (if any)
  const saved = Number(localStorage.getItem(KEY));
  if(Number.isFinite(saved) && saved > 0){
    applyHeight(saved, false);
  }

  let dragging = false;
  let startY = 0;
  let startH = 0;

  function onDown(e){
    dragging = true;
    startY = (e.touches && e.touches[0]) ? e.touches[0].clientY : e.clientY;
    startH = el.viewer.getBoundingClientRect().height;
    el.viewerResize.classList.add("dragging");
    try{ el.viewerResize.setPointerCapture?.(e.pointerId); }catch(_){}
    e.preventDefault();
  }
  function onMove(e){
    if(!dragging) return;
    const y = (e.touches && e.touches[0]) ? e.touches[0].clientY : e.clientY;
    const delta = y - startY;
    applyHeight(startH + delta, true);
    e.preventDefault();
  }
  function onUp(e){
    if(!dragging) return;
    dragging = false;
    el.viewerResize.classList.remove("dragging");
    e.preventDefault();
  }

  el.viewerResize.addEventListener("pointerdown", onDown);
  window.addEventListener("pointermove", onMove, {passive:false});
  window.addEventListener("pointerup", onUp, {passive:false});

  // Touch fallback
  el.viewerResize.addEventListener("touchstart", onDown, {passive:false});
  window.addEventListener("touchmove", onMove, {passive:false});
  window.addEventListener("touchend", onUp, {passive:false});

  // Double-click to reset
  el.viewerResize.addEventListener("dblclick", () => {
    localStorage.removeItem(KEY);
    root.style.removeProperty("--viewerHeight");
  });

  // Keep within bounds on resize
  window.addEventListener("resize", () => {
    const cur = parseFloat(getComputedStyle(root).getPropertyValue("--viewerHeight"));
    if(Number.isFinite(cur) && cur > 0) applyHeight(cur, false);
  });
})();

// -----------------------------
// Read aloud (Text-to-Speech)
// -----------------------------
const tts = {
  active: false,           // enabled (listening and/or reading)
  live: false,             // live from-now mode
  snapshot: null,          // captured filters at Play time
  lastProcessedId: 0,      // last seen item id when live
  queue: [],               // pending strings to speak
  idx: 0,                  // used for non-live backlog mode
  currentUtterance: null,
  userPlaying: false        // UI highlight while Play session is active,
};


// Highlight messages in the viewer when a trigger phrase fires.
function ttsApplyHighlight({speakerKey="", itemId=null, durationMs=20000, highlightSpeaker=true, highlightLine=true} = {}){
  if(!el.viewer) return;

  const norm = String(speakerKey || "");
  const dur = Math.max(250, Number(durationMs) || 20000);

  // Persist highlight state so virtualized rendering can apply it as rows are created
  state.ttsHiSpeakerKey = (highlightSpeaker && norm) ? norm : "";
  state.ttsHiItemId = (highlightLine && itemId != null) ? itemId : null;
  state.ttsHiUntil = Date.now() + dur;

  // Apply to currently rendered rows
  for(const r of el.viewer.querySelectorAll(".msg.tts-speaker")) r.classList.remove("tts-speaker");
  for(const r of el.viewer.querySelectorAll(".msg.tts-hit")) r.classList.remove("tts-hit");

  for(const r of el.viewer.querySelectorAll(".msg")){
    if(state.ttsHiSpeakerKey && (r.dataset.fromkey || "") === state.ttsHiSpeakerKey) r.classList.add("tts-speaker");
    if(state.ttsHiItemId != null && (r.dataset.id || "") === String(state.ttsHiItemId)) r.classList.add("tts-hit");
  }

  // Auto-clear after duration
  clearTimeout(ttsApplyHighlight._t);
  ttsApplyHighlight._t = setTimeout(() => {
    state.ttsHiSpeakerKey = "";
    state.ttsHiItemId = null;
    state.ttsHiUntil = 0;
    if(!el.viewer) return;
    for(const r of el.viewer.querySelectorAll(".msg.tts-speaker")) r.classList.remove("tts-speaker");
    for(const r of el.viewer.querySelectorAll(".msg.tts-hit")) r.classList.remove("tts-hit");
  }, dur);
}



function ttsSupported(){
  return !!(window.speechSynthesis && window.SpeechSynthesisUtterance);
}
function ttsSetStatus(msg){
  if(el.ttsStatus) el.ttsStatus.textContent = msg || "";
}
function ttsSetButtons(){
  const speaking = ttsSupported() && (speechSynthesis.speaking || speechSynthesis.pending);
  if(el.ttsPause) el.ttsPause.disabled = !(tts.active && speaking);
  if(el.ttsStop) el.ttsStop.disabled = !(tts.active || speaking);
  if(el.ttsPlay) el.ttsPlay.disabled = !ttsSupported();
  if(el.ttsPlay) el.ttsPlay.classList.toggle("playing", !!tts.userPlaying);
  if(el.ttsTest) el.ttsTest.disabled = !ttsSupported();
  if(el.ttsPause){
    el.ttsPause.textContent = (ttsSupported() && speechSynthesis.paused) ? "‚ñ∂Ô∏è Resume" : "‚è∏ Pause";
  }
}

function ttsNormalizeName(s){
  return (s || "").trim().replace(/:+\s*$/,"").trim();
}
function ttsNormalizeChannelName(s){
  let x = (s || "").trim().replace(/^\[|\]$/g,"");
  if(!x) return "";
  return normalizeChannel(x);
}
function parseChannelList(s){
  const raw = (s || "").trim();
  if(!raw) return [];
  // Comma-separated list. Example: "Global, Help, Tell"
  const parts = raw.split(",").map(x => (x || "").trim()).filter(Boolean);
  // Treat "All", "Any" or "*" as no channel restriction
  if(parts.some(p => {
    const t = p.toLowerCase();
    return t === "all" || t === "any" || t === "*";
  })) return [];
  return parts
    .map(x => ttsNormalizeChannelName(x).toLowerCase())
    .filter(Boolean);
}
function ttsNormalizeKey(s){
  return (s || "").toLowerCase().trim()
    .replace(/:+\s*$/,"")
    .replace(/\s+/g," ");
}
function ttsEscapeRegExp(s){
  return (s || "").replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

function ttsNormalizePhrase(s){
  return (s || "").trim().toLowerCase().replace(/\s+/g," ");
}

function ttsSpeakerOf(it){
  if(it && it.from) return String(it.from);
  const raw = String((it && (it.raw ?? it.text)) ?? "");
  // Try "...[Channel] Name: message"
  let m = raw.match(/\]\s*([^:]{1,60}):\s*/);
  if(m) return m[1].trim();
  // Try "Name: message" at start (pasted/unparsed lines)
  m = raw.match(/^([^:]{1,60}):\s*/);
  if(m) return m[1].trim();
  return "";
}

function ttsPopulateVoices(){
  if(!el.ttsVoice) return;
  const voices = speechSynthesis.getVoices ? speechSynthesis.getVoices() : [];
  el.ttsVoice.innerHTML = "";
  if(!voices.length){
    const opt = document.createElement("option");
    opt.value = "";
    opt.textContent = "Default";
    el.ttsVoice.appendChild(opt);
    return;
  }

  // Prefer English voices first, then everything else (stable ordering)
  const sorted = [...voices].sort((a,b) => {
    const ae = (a.lang || "").toLowerCase().startsWith("en") ? 0 : 1;
    const be = (b.lang || "").toLowerCase().startsWith("en") ? 0 : 1;
    if(ae !== be) return ae - be;
    return (a.name || "").localeCompare(b.name || "");
  });

  for(const v of sorted){
    const opt = document.createElement("option");
    opt.value = v.voiceURI || v.name;
    opt.textContent = `${v.name}${v.lang ? " ("+v.lang+")" : ""}${v.default ? " ‚Äî default" : ""}`;
    el.ttsVoice.appendChild(opt);
  }
}

function ttsGetSelectedVoice(){
  if(!el.ttsVoice) return null;
  const want = el.ttsVoice.value || "";
  const voices = speechSynthesis.getVoices ? speechSynthesis.getVoices() : [];
  if(!want) return null;
  return voices.find(v => (v.voiceURI || v.name) === want) || null;
}



function ttsDiagnostics(){
  const supported = ttsSupported();
  if(!supported) return "unsupported";
  const voices = (speechSynthesis.getVoices ? speechSynthesis.getVoices() : []) || [];
  const v = ttsGetSelectedVoice();
  return `voices:${voices.length}${v ? " | " + v.name : ""}`;
}

function ttsSpeakOnce(msg, {onStart, onEnd} = {}){
  if(!ttsSupported()) return null;

  // Some browsers require these inside the user gesture.
  try{ speechSynthesis.getVoices && speechSynthesis.getVoices(); }catch(e){}
  try{ speechSynthesis.resume(); }catch(e){}

  const u = new SpeechSynthesisUtterance(msg);

  const v = ttsGetSelectedVoice();
  if(v) u.voice = v;

  const rate = parseFloat(el.ttsRate?.value || "1");
  if(isFinite(rate)) u.rate = rate;

  if(onStart) u.onstart = onStart;
  u.onend = () => { if(onEnd) onEnd(); };
  u.onerror = () => { if(onEnd) onEnd(true); };

  // Watchdog: if speech doesn't start quickly, try a gentle kick once.
  let kicked = false;
  const kick = () => {
    if(kicked) return;
    kicked = true;
    try{ speechSynthesis.cancel(); }catch(e){}
    try{ speechSynthesis.resume(); }catch(e){}
    try{ speechSynthesis.speak(u); }catch(e){}
    setTimeout(() => {
      if(!speechSynthesis.speaking && !speechSynthesis.pending){
        ttsSetStatus("Speech didn't start. If you're opening the file directly, try running it via a local server (or use Chrome/Edge).");
        ttsSetButtons();
      }
    }, 600);
  };

  setTimeout(() => {
    if(!speechSynthesis.speaking && !speechSynthesis.pending) kick();
  }, 450);

  // Small delay after cancel() helps some engines.
  setTimeout(() => {
    try{ speechSynthesis.speak(u); }catch(e){
      ttsSetStatus("Unable to start speech: " + (e?.message || e));
    }
    ttsSetButtons();
  }, 40);

  return u;
}

function ttsMakeSnapshot(){
  const channelRaw = el.ttsChannel?.value || "";
  const speakerRaw = el.ttsSpeaker?.value || "";
  const phraseRaw  = el.ttsPhrase?.value || "";
  const scope = el.ttsScope?.value || "tab";
  const sayChannel = !!el.ttsSayChannel?.checked;

  // Channel filter supports comma-separated values (e.g. "Global, Guild, Combat").
  // Special values "All", "Any" or "*" mean: no channel restriction.
  const wantChannels = parseChannelList(channelRaw);
  const wantChannelSet = wantChannels.length ? new Set(wantChannels) : null;

  const wantSpeaker = ttsNormalizeKey(ttsNormalizeName(speakerRaw));
  const wantPhrase  = ttsNormalizePhrase(phraseRaw);

  // For tab scope, capture the current tab + top search value at Play time so "live" stays consistent.
  const activeChannel = state.activeChannel;
  const search = state.search || "";

  return { scope, sayChannel, wantChannels, wantChannelSet, wantSpeaker, wantPhrase, activeChannel, search };
}

function ttsSnapshotItems(snap){
  if(!snap) return [];
  if(snap.scope === "all") return state.all || [];
  // Tab scope with snapshot of channel + search
  let items = (snap.activeChannel === "All") ? (state.all || []) : (state.channels.get(snap.activeChannel) ?? []);
  const q = (snap.search || "").trim().toLowerCase();
  const qNoColon = q.replace(/:+\s*$/,"");
  if(q){
    items = items.filter(it => {
      const ts = (it.ts || "").toLowerCase();
      const ch = (it.channel || "").toLowerCase();
      const from = (it.from || "").toLowerCase();
      const msg = (it.text || "").toLowerCase();
      return ts.includes(q) ||
             ch.includes(q) ||
             from.includes(qNoColon || q) ||
             msg.includes(q);
    });
  }
  return items;
}


function ttsQueueEntryForItem(it, snap){
  let speakText = (it.text || "").trim();
  if(!speakText) return null;

  // Ensure we never read the speaker name; strip "Name:" if present in text.
  const sp = ttsSpeakerOf(it);
  if(sp){
    const re = new RegExp("^" + ttsEscapeRegExp(sp) + "\s*:\s*", "i");
    speakText = speakText.replace(re, "").trim();
  }
  if(!speakText) return null;

  let phraseHit = false;
  if(snap?.wantPhrase){
    const msgLc = speakText.toLowerCase();
    if(!msgLc.includes(snap.wantPhrase)) return null;
    phraseHit = true;
  }

  const parts = [];
  if(snap?.sayChannel && it.channel) parts.push(`[${it.channel}]`);
  parts.push(speakText);

  return {
    text: parts.join(" "),
    speakerKey: ttsNormalizeKey(ttsSpeakerOf(it)),
    itemId: (it && it.id != null) ? it.id : null,
    phraseHit
  };
}


function ttsItemMatchesFilters(it, snap){
  if(!it || !snap) return false;

  // Respect Scope=Current tab: only match messages from the currently selected channel tab (unless you're on All).
  if(snap.scope === "tab" && snap.activeChannel && snap.activeChannel !== "All"){
    if((it.channel || "") !== snap.activeChannel) return false;
  }

  // Respect the main top search filter captured at Play time (for tab scope).
  const q = (snap.scope === "tab" ? (snap.search || "").trim().toLowerCase() : "");
  if(q){
    const qNoColon = q.replace(/:+\s*$/,"");
    const ts = (it.ts || "").toLowerCase();
    const ch = (it.channel || "").toLowerCase();
    const from = (ttsSpeakerOf(it) || "").toLowerCase();
    const msg = (it.text || "").toLowerCase();
    if(!(ts.includes(q) || ch.includes(q) || from.includes(qNoColon || q) || msg.includes(q))) return false;
  }

  if(snap.wantChannelSet){
    if(!snap.wantChannelSet.has(((it.channel || "").toLowerCase()))) return false;
  }

  if(snap.wantSpeaker){
    if(!ttsNormalizeKey(ttsSpeakerOf(it)).includes(snap.wantSpeaker)) return false;
  }

  // Phrase match is checked later (after "Name:" stripping)
  return true;
}


function ttsBuildQueueFromSnapshot(snap){
  let items = ttsSnapshotItems(snap);

  if(snap.wantChannelSet){
    items = items.filter(it => snap.wantChannelSet.has((it.channel || "").toLowerCase()));
  }
  if(snap.wantSpeaker){
    items = items.filter(it => ttsNormalizeKey(ttsSpeakerOf(it)).includes(snap.wantSpeaker));
  }

  const out = [];
  for(const it of items){
    const entry = ttsQueueEntryForItem(it, snap);
    if(entry) out.push(entry);
  }
  return out;
}


function ttsStop(){
  if(ttsSupported()){
    try{ speechSynthesis.cancel(); }catch(e){}
  }
  tts.active = false;
  tts.userPlaying = false;
  tts.live = false;
  tts.snapshot = null;
  tts.lastProcessedId = 0;
  tts.queue = [];
  tts.idx = 0;
  tts.currentUtterance = null;
  ttsSetStatus("");
  ttsSetButtons();
}



function ttsSpeakNext(){
  if(!ttsSupported()) return;
  if(!tts.active) return;

  if(tts.live){
    if(!tts.queue.length){
      ttsSetStatus("Listening for new matching messages‚Ä¶ (" + ttsDiagnostics() + ")");
      ttsSetButtons();
      return;
    }
    const entry = tts.queue.shift();
    const msgText = (entry && entry.text) ? entry.text : "";
    tts.currentUtterance = ttsSpeakOnce(msgText, {
      onStart: () => {
        if(entry?.phraseHit) ttsApplyHighlight({ speakerKey: entry.speakerKey, itemId: entry.itemId });
        ttsSetStatus(`Speaking (live)‚Ä¶ (${ttsDiagnostics()})`);
        ttsSetButtons();
      },
      onEnd: () => {
        ttsSpeakNext();
      }
    });
    if(!tts.currentUtterance){
      tts.active = false;
      tts.live = false;
      ttsSetStatus("Text-to-speech is not available in this browser.");
      ttsSetButtons();
    }
    return;
  }

  if(tts.idx >= tts.queue.length){
    tts.active = false;
    tts.userPlaying = false;
    ttsSetStatus("Finished.");
    ttsSetButtons();
    return;
  }

  const entry = tts.queue[tts.idx];
  const msgText = (entry && entry.text) ? entry.text : "";
  tts.currentUtterance = ttsSpeakOnce(msgText, {
    onStart: () => {
      if(entry?.phraseHit) ttsApplyHighlight({ speakerKey: entry.speakerKey, itemId: entry.itemId });
      ttsSetStatus(`Speaking ${tts.idx + 1}/${tts.queue.length} (${ttsDiagnostics()})`);
      ttsSetButtons();
    },
    onEnd: () => {
      tts.idx++;
      ttsSpeakNext();
    }
  });

  if(!tts.currentUtterance){
    tts.active = false;
    ttsSetStatus("Text-to-speech is not available in this browser.");
    ttsSetButtons();
  }else{
    ttsSetStatus(`Starting ${tts.idx + 1}/${tts.queue.length}‚Ä¶ (${ttsDiagnostics()})`);
    ttsSetButtons();
  }
}

function ttsPlay(){
  if(!ttsSupported()){
    ttsSetStatus("Text-to-speech is not supported in this browser.");
    return;
  }

  try{ ttsPopulateVoices(); }catch(e){}
  try{ speechSynthesis.getVoices && speechSynthesis.getVoices(); }catch(e){}
  try{ speechSynthesis.resume(); }catch(e){}

  ttsStop();
  tts.userPlaying = true;

  const snap = ttsMakeSnapshot();
  const wantLive = !!el.ttsLive?.checked;

  if(wantLive){
    tts.active = true;
    tts.live = true;
    tts.snapshot = snap;
    tts.queue = [];
    tts.idx = 0;
    tts.lastProcessedId = state.nextId || 0;

    ttsSetStatus("Listening for new matching messages‚Ä¶ (" + ttsDiagnostics() + ")");
    ttsSetButtons();
    return;
  }

  const q = ttsBuildQueueFromSnapshot(snap);
  if(!q.length){
    tts.userPlaying = false;
    ttsSetStatus("No matching lines to read (check scope/channel/speaker/phrase).");
    ttsSetButtons();
    return;
  }
  tts.queue = q;
  tts.idx = 0;
  tts.active = true;
  tts.live = false;
  tts.snapshot = snap;

  ttsSetStatus(`Queued ${q.length} line(s)‚Ä¶ (${ttsDiagnostics()})`);
  ttsSetButtons();
  ttsSpeakNext();
}


function ttsHandleNewItems(newItems){
  if(!tts.active || !tts.live || !tts.snapshot) return;
  if(!newItems || !newItems.length) return;

  for(const it of newItems){
    const id = it?.id ?? 0;
    if(id <= (tts.lastProcessedId || 0)) continue;
    tts.lastProcessedId = id;

    if(!ttsItemMatchesFilters(it, tts.snapshot)) continue;
    const entry = ttsQueueEntryForItem(it, tts.snapshot);
    if(!entry) continue;

    tts.queue.push(entry);
  }

  if(tts.queue.length && !(speechSynthesis.speaking || speechSynthesis.pending)){
    ttsSpeakNext();
  }else{
    ttsSetButtons();
  }
}


function ttsTogglePause(){
  if(!ttsSupported()) return;
  if(!speechSynthesis.speaking && !speechSynthesis.pending){
    ttsSetButtons();
    return;
  }
  if(speechSynthesis.paused) speechSynthesis.resume();
  else speechSynthesis.pause();
  ttsSetButtons();



}

function ttsTest(){
  if(!ttsSupported()){
    ttsSetStatus("Text-to-speech is not supported in this browser.");
    return;
  }
  // Stop any current speech and speak a short phrase
  try{ speechSynthesis.cancel(); }catch(e){}
  tts.active = false;
  tts.userPlaying = false;
  tts.queue = [];
  tts.idx = 0;

  ttsSetStatus("Testing speech‚Ä¶ (" + ttsDiagnostics() + ")");
  ttsSetButtons();

  ttsSpeakOnce("Test speech. If you can hear this, text to speech is working.", {
    onStart: () => { ttsSetStatus("Test speaking‚Ä¶ (" + ttsDiagnostics() + ")"); ttsSetButtons(); },
    onEnd: () => { ttsSetStatus("Test complete. (" + ttsDiagnostics() + ")"); ttsSetButtons(); }
  });
}

function initTTS(){
  if(!el.ttsPlay) return; // UI not present
  if(!ttsSupported()){
    ttsSetStatus("Text-to-speech is not supported in this browser.");
    ttsSetButtons();
    return;
  }

  // Populate voices (some browsers load voices async)
  ttsPopulateVoices();
  speechSynthesis.onvoiceschanged = () => ttsPopulateVoices();

  el.ttsPlay.addEventListener("click", ttsPlay);
  el.ttsTest?.addEventListener("click", ttsTest);
  el.ttsPause.addEventListener("click", ttsTogglePause);
  el.ttsStop.addEventListener("click", ttsStop);

  // If the user changes voice/rate while speaking, apply on next line
  el.ttsVoice?.addEventListener("change", () => {});
  el.ttsRate?.addEventListener("change", () => {});

  ttsSetButtons();
}


// -----------------------------
// Alert rules (multiple)
// -----------------------------
const ALERTS_KEY = "pg_alert_rules_v1";
const ALERTS_ENABLED_KEY = "pg_alerts_enabled_v1";

const MENTIONS_KEY = "pg_mentions_v1";

const mentions = {
  enabled: false,
  namesRaw: "",
  names: [],        // normalized strings
  regexes: [],      // compiled regexes
  scope: "all",     // "tab" | "all"
  actSpeak: true,
  actHiSpeaker: true,
  actHiLine: true,
  durationSec: 20,
  cooldownSec: 2,
};

function mentionsSetStatus(msg){
  if(el.mentionsStatus) el.mentionsStatus.textContent = msg || "";
}

function mentionsNormalizeName(s){
  return (s || "").trim().replace(/:+$/g, "");
}

function mentionsParseNames(raw){
  const parts = (raw || "").split(",").map(x => mentionsNormalizeName(x)).filter(Boolean);
  // de-dup while preserving order
  const seen = new Set();
  const out = [];
  for(const p of parts){
    const k = p.toLowerCase();
    if(seen.has(k)) continue;
    seen.add(k);
    out.push(p);
  }
  return out;
}

function mentionsBuildRegexes(names){
  const regs = [];
  for(const nm of (names || [])){
    const esc = nm.replace(/[.*+?^${}()|[\[\]\\]/g, "\\$&");
    // If the name is simple word chars, use word boundaries to reduce false positives
    if(/^[a-z0-9_]+$/i.test(nm)){
      regs.push(new RegExp("\\b" + esc + "\\b", "i"));
    }else{
      regs.push(new RegExp(esc, "i"));
    }
  }
  return regs;
}

function mentionsLoad(){
  try{
    const raw = localStorage.getItem(MENTIONS_KEY);
    if(raw){
      const m = JSON.parse(raw) || {};
      mentions.enabled = !!m.enabled;
      mentions.namesRaw = (m.namesRaw || "");
      mentions.scope = (m.scope === "tab" ? "tab" : "all");
      mentions.actSpeak = (m.actSpeak !== false); // default true
      mentions.actHiSpeaker = (m.actHiSpeaker !== false);
      mentions.actHiLine = (m.actHiLine !== false);
      mentions.durationSec = Number(m.durationSec || 20) || 20;
      mentions.cooldownSec = Number(m.cooldownSec || 2) || 2;
    }
  }catch(_){}
  mentions.names = mentionsParseNames(mentions.namesRaw);
  mentions.regexes = mentionsBuildRegexes(mentions.names);
}

function mentionsSave(){
  try{
    localStorage.setItem(MENTIONS_KEY, JSON.stringify({
      enabled: mentions.enabled,
      namesRaw: mentions.namesRaw,
      scope: mentions.scope,
      actSpeak: mentions.actSpeak,
      actHiSpeaker: mentions.actHiSpeaker,
      actHiLine: mentions.actHiLine,
      durationSec: mentions.durationSec,
      cooldownSec: mentions.cooldownSec,
    }));
  }catch(_){}
}

function mentionsRenderToUI(){
  if(el.mentionsEnabled) el.mentionsEnabled.checked = !!mentions.enabled;
  if(el.mentionsNames) el.mentionsNames.value = mentions.namesRaw || "";
  if(el.mentionsScope) el.mentionsScope.value = mentions.scope || "all";
  if(el.mentionsSpeak) el.mentionsSpeak.checked = !!mentions.actSpeak;
  if(el.mentionsHiSpeaker) el.mentionsHiSpeaker.checked = !!mentions.actHiSpeaker;
  if(el.mentionsHiLine) el.mentionsHiLine.checked = !!mentions.actHiLine;
  if(el.mentionsDuration) el.mentionsDuration.value = String(mentions.durationSec || 20);
  if(el.mentionsCooldown) el.mentionsCooldown.value = String(mentions.cooldownSec || 2);
}

function mentionsReadFromUI(){
  mentions.enabled = !!el.mentionsEnabled?.checked;
  mentions.namesRaw = (el.mentionsNames?.value || "");
  mentions.scope = (el.mentionsScope?.value === "tab" ? "tab" : "all");
  mentions.actSpeak = !!el.mentionsSpeak?.checked;
  mentions.actHiSpeaker = !!el.mentionsHiSpeaker?.checked;
  mentions.actHiLine = !!el.mentionsHiLine?.checked;
  mentions.durationSec = Number(el.mentionsDuration?.value || 20) || 20;
  mentions.cooldownSec = Number(el.mentionsCooldown?.value || 2) || 2;

  mentions.names = mentionsParseNames(mentions.namesRaw);
  mentions.regexes = mentionsBuildRegexes(mentions.names);
}

function mentionsItemInScope(it){
  if(mentions.scope === "tab" && state.activeChannel && state.activeChannel !== "All"){
    return ((it.channel || "") === state.activeChannel);
  }
  return true;
}

function mentionsMatches(it){
  if(!mentions.enabled) return false;
  if(!it) return false;
  if(!mentions.names.length) return false;
  if(!mentionsItemInScope(it)) return false;
  const msg = (it.text || "").toString();
  if(!msg) return false;
  for(const rx of mentions.regexes){
    try{ if(rx.test(msg)) return true; }catch(_){}
  }
  return false;
}

function mentionsFire(it){
  const now = Date.now();
  const key = "__mentions__";
  const last = alerts.cooldownMap.get(key) || 0;
  const cooldownMs = Math.max(0, (mentions.cooldownSec || 0) * 1000);
  if(cooldownMs && (now - last) < cooldownMs) return;
  alerts.cooldownMap.set(key, now);

  const base = (it.text || "").toString();
  const spoken = (it.channel ? `[${it.channel}] ` : "") + base;
  const durationMs = Math.max(250, (mentions.durationSec || 20) * 1000);

  if(mentions.actSpeak){
    if(ttsSupported()){
      ttsSpeakOnce(spoken, {
        onStart: () => { mentionsSetStatus("Mention detected ‚Äî speaking‚Ä¶"); },
        onEnd: () => { /* keep status */ }
      });
    }else{
      mentionsSetStatus("TTS not supported in this browser.");
    }
  }

  if(mentions.actHiSpeaker || mentions.actHiLine){
    ttsApplyHighlight({
      speakerKey: ttsNormalizeKey(ttsSpeakerOf(it)),
      itemId: it?.id ?? null,
      durationMs,
      highlightSpeaker: !!mentions.actHiSpeaker,
      highlightLine: !!mentions.actHiLine
    });
  }

  const who = ttsSpeakerOf(it) || "Someone";
  mentionsSetStatus(`Mention by ${who} (${it.channel || "Unparsed"}).`);
}

const alerts = {
  enabled: false,
  lastProcessedId: 0,     // ignore older lines until armed
  rules: [],
  editingId: null,
  cooldownMap: new Map(), // ruleId -> last fired timestamp
};

let _ruleSoundDataUrl = "";
let _ruleSoundName = "";

function ruleSoundSet(dataUrl, name){
  _ruleSoundDataUrl = dataUrl || "";
  _ruleSoundName = name || "";
  if(el.ruleSoundLabel){
    el.ruleSoundLabel.textContent = _ruleSoundName
      ? `Sound: ${_ruleSoundName}`
      : (_ruleSoundDataUrl ? "Sound selected" : "No sound selected");
  }
}

function ruleSoundShowIfNeeded(){
  const on = !!el.ruleActSound?.checked;
  if(el.ruleSoundRow) el.ruleSoundRow.style.display = on ? "flex" : "none";
}

function playSoundDataUrl(dataUrl){
  if(!dataUrl) return;
  // Try to unlock audio context (helps in some browsers)
  try{
    if(!window.__pgAudioCtx){
      window.__pgAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    window.__pgAudioCtx.resume?.();
  }catch(_){}

  try{
    const a = new Audio(dataUrl);
    a.preload = "auto";
    const p = a.play();
    if(p && typeof p.catch === "function"){
      p.catch(() => {
        alertsSetStatus("Sound blocked by browser until you interact with the page (click once, then try again).");
      });
    }
  }catch(e){
    alertsSetStatus("Could not play sound: " + (e?.message || e));
  }
}

function alertsSetStatus(msg){
  if(el.alertsStatus) el.alertsStatus.textContent = msg || "";
}
function alertsLoad(){
  try{
    const enabled = localStorage.getItem(ALERTS_ENABLED_KEY);
    alerts.enabled = (enabled === "1");
  }catch(_){}
  try{
    const raw = localStorage.getItem(ALERTS_KEY);
    alerts.rules = raw ? (JSON.parse(raw) || []) : [];
  }catch(_){
    alerts.rules = [];
  }
}
function alertsSave(){
  try{ localStorage.setItem(ALERTS_ENABLED_KEY, alerts.enabled ? "1" : "0"); }catch(_){}
  try{ localStorage.setItem(ALERTS_KEY, JSON.stringify(alerts.rules || [])); }catch(_){}
}
function alertsArmFromNow(){
  alerts.lastProcessedId = state.nextId || 0;
  alertsSetStatus("Armed from now (ignoring older lines).");
}

function ruleSummary(r){
  const bits = [];
  if(r.scope === "tab") bits.push("tab");
  else bits.push("all");
  if(r.channel) bits.push("channel:"+r.channel);
  if(r.speaker) bits.push("speaker:"+r.speaker);
  if(r.phrase) bits.push("phrase:\""+r.phrase+"\"");
  const acts = [];
  if(r.actSpeak) acts.push("speak");
  if(r.actHiSpeaker) acts.push("hi speaker");
  if(r.actHiLine) acts.push("hi line");
  if(r.actSound && r.soundDataUrl) acts.push("sound");
  bits.push("‚Üí " + (acts.join(", ") || "no actions"));
  return bits.join(" ¬∑ ");
}

function alertsRenderList(){
  if(!el.rulesList) return;
  el.rulesList.innerHTML = "";
  if(!alerts.rules.length){
    const div = document.createElement("div");
    div.className = "muted";
    div.style.fontSize = "12px";
    div.textContent = "No rules yet. Click ‚ÄúAdd rule‚Äù to create one.";
    el.rulesList.appendChild(div);
    return;
  }

  for(const r of alerts.rules){
    const item = document.createElement("div");
    item.className = "ruleItem";

    const left = document.createElement("div");
    left.className = "ruleMain";

    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.checked = !!r.enabled;
    cb.addEventListener("change", () => {
      r.enabled = cb.checked;
      alertsSave();
      alertsSetStatus(r.enabled ? `Enabled ‚Äú${r.name || "rule"}‚Äù.` : `Disabled ‚Äú${r.name || "rule"}‚Äù.`);
    });

    const txt = document.createElement("div");
    txt.className = "ruleText";
    const nm = document.createElement("div");
    nm.className = "ruleName";
    nm.textContent = r.name || "Untitled rule";
    const desc = document.createElement("div");
    desc.className = "ruleDesc";
    desc.textContent = ruleSummary(r);
    txt.appendChild(nm);
    txt.appendChild(desc);

    left.appendChild(cb);
    left.appendChild(txt);

    const btns = document.createElement("div");
    btns.className = "ruleBtns";

    const edit = document.createElement("button");
    edit.className = "btn miniBtn";
    edit.textContent = "‚úèÔ∏è Edit";
    edit.addEventListener("click", () => alertsOpenEditor(r));

    const del = document.createElement("button");
    del.className = "btn miniBtn";
    del.textContent = "üóë Delete";
    del.addEventListener("click", () => {
      const idx = alerts.rules.findIndex(x => x.id === r.id);
      if(idx >= 0) alerts.rules.splice(idx, 1);
      alertsSave();
      alertsRenderList();
      alertsSetStatus("Rule deleted.");
    });

    btns.appendChild(edit);
    btns.appendChild(del);

    item.appendChild(left);
    item.appendChild(btns);
    el.rulesList.appendChild(item);
  }
}

function alertsOpenEditor(rule=null){
  if(!el.ruleEditor) return;
  el.ruleEditor.style.display = "block";
  alerts.editingId = rule ? rule.id : null;

  el.ruleName.value = rule?.name || "";
  el.ruleEnabled.checked = (rule ? !!rule.enabled : true);
  el.ruleScope.value = rule?.scope || "all";
  el.ruleChannel.value = rule?.channel || "";
  el.ruleSpeaker.value = rule?.speaker || "";
  el.rulePhrase.value = rule?.phrase || "";

  el.ruleActSpeak.checked = (rule ? !!rule.actSpeak : true);
  el.ruleActHiSpeaker.checked = (rule ? !!rule.actHiSpeaker : true);
  el.ruleActHiLine.checked = (rule ? !!rule.actHiLine : true);
  el.ruleActSound.checked = (rule ? !!rule.actSound : false);

  ruleSoundSet(rule?.soundDataUrl || "", rule?.soundName || "");
  ruleSoundShowIfNeeded();

  el.ruleDuration.value = String(rule?.durationSec ?? 20);
  el.ruleCooldown.value = String(rule?.cooldownSec ?? 2);

  alertsSetStatus(rule ? `Editing ‚Äú${rule.name || "rule"}‚Äù‚Ä¶` : "Creating new rule‚Ä¶");
}

function alertsCloseEditor(){
  if(!el.ruleEditor) return;
  el.ruleEditor.style.display = "none";
  alerts.editingId = null;
  ruleSoundSet("", "");
  if(el.ruleActSound) el.ruleActSound.checked = false;
  ruleSoundShowIfNeeded();
}

function alertsReadEditor(){
  const name = (el.ruleName.value || "").trim() || "Untitled rule";
  const enabled = !!el.ruleEnabled.checked;
  const scope = el.ruleScope.value || "all";
  const channel = parseChannelList(el.ruleChannel.value || "").join(", ");
  const speaker = ttsNormalizeKey(ttsNormalizeName(el.ruleSpeaker.value || ""));
  const phrase = ttsNormalizePhrase(el.rulePhrase.value || "");

  const actSpeak = !!el.ruleActSpeak.checked;
  const actHiSpeaker = !!el.ruleActHiSpeaker.checked;
  const actHiLine = !!el.ruleActHiLine.checked;
  const actSound = !!el.ruleActSound.checked;

  const durationSec = Math.max(1, parseFloat(el.ruleDuration.value || "20") || 20);
  const cooldownSec = Math.max(0, parseFloat(el.ruleCooldown.value || "0") || 0);

  return {
    name, enabled, scope,
    channel, speaker, phrase,
    actSpeak, actHiSpeaker, actHiLine, actSound,
    soundDataUrl: (actSound ? (_ruleSoundDataUrl || "") : ""),
    soundName: (actSound ? (_ruleSoundName || "") : ""),
    durationSec, cooldownSec
  };
}

function alertsUpsertRule(ruleData){
  if(alerts.editingId){
    const r = alerts.rules.find(x => x.id === alerts.editingId);
    if(r) Object.assign(r, ruleData);
  }else{
    alerts.rules.push({ id: "r_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2,7), ...ruleData });
  }
  alertsSave();
  alertsRenderList();
}

function alertRuleMatches(r, it){
  if(!r || !it) return false;

  // Scope
  if(r.scope === "tab" && state.activeChannel && state.activeChannel !== "All"){
    if((it.channel || "") !== state.activeChannel) return false;
  }
  const ruleChannels = parseChannelList(r.channel);
  if(ruleChannels.length){
    const itCh = (ttsNormalizeChannelName(it.channel || "Unparsed") || "Unparsed").toLowerCase();
    if(!ruleChannels.includes(itCh)) return false;
  }

  if(r.speaker){
    const fromKey = ttsNormalizeKey(ttsSpeakerOf(it));
    if(!fromKey.includes(r.speaker)) return false;
  }

  if(r.phrase){
    // phrase should match the message text after stripping Name:
    const snap = { sayChannel:false, wantPhrase:r.phrase };
    const entry = ttsQueueEntryForItem(it, snap);
    if(!entry) return false;
    // ttsQueueEntryForItem already ensures phrase match if wantPhrase set
    if(!entry.phraseHit) return false;
  }

  return true;
}

function alertsFireRule(r, it){
  const now = Date.now();
  const last = alerts.cooldownMap.get(r.id) || 0;
  const cooldownMs = Math.max(0, (r.cooldownSec || 0) * 1000);
  if(cooldownMs && (now - last) < cooldownMs) return;
  alerts.cooldownMap.set(r.id, now);

  // Build message text (never speak the speaker name)
  const entry = ttsQueueEntryForItem(it, { sayChannel:false, wantPhrase:"" });
  const base = entry?.text || (it.text || "");
  const spoken = (it.channel ? `[${it.channel}] ` : "") + base;

  const durationMs = Math.max(250, (r.durationSec || 20) * 1000);

  if(r.actSound && r.soundDataUrl){
    playSoundDataUrl(r.soundDataUrl);
  }

  if(r.actSpeak){
    if(ttsSupported()){
      // Queue the utterance
      ttsSpeakOnce(spoken, {
        onStart: () => { alertsSetStatus(`Rule ‚Äú${r.name}‚Äù speaking‚Ä¶`); },
        onEnd: () => { /* keep last status */ }
      });
    }else{
      alertsSetStatus("TTS not supported in this browser.");
    }
  }

  if(r.actHiSpeaker || r.actHiLine){
    ttsApplyHighlight({
      speakerKey: ttsNormalizeKey(ttsSpeakerOf(it)),
      itemId: it?.id ?? null,
      durationMs,
      highlightSpeaker: !!r.actHiSpeaker,
      highlightLine: !!r.actHiLine
    });
  }

  alertsSetStatus(`Rule fired: ‚Äú${r.name}‚Äù`);
}

function alertsHandleNewItems(newItems){
  if(!alerts.enabled && !mentions.enabled) return;
  if(!newItems || !newItems.length) return;

  for(const it of newItems){
    const id = it?.id ?? 0;
    if(id <= (alerts.lastProcessedId || 0)) continue;
    alerts.lastProcessedId = id;

    for(const r of alerts.rules){
      if(!r.enabled) continue;
      if(alertRuleMatches(r, it)) alertsFireRule(r, it);
    }

    // Mentions (quick toggle)
    if(mentionsMatches(it)) mentionsFire(it);
  }
}

function initAlerts(){
  if(!el.alertsBox) return;

  alertsLoad();
  mentionsLoad();
  mentionsRenderToUI();
  if(el.alertsEnabled) el.alertsEnabled.checked = alerts.enabled;
  if(el.mentionsEnabled) el.mentionsEnabled.checked = mentions.enabled;

  alertsRenderList();

  el.alertsEnabled?.addEventListener("change", () => {
    alerts.enabled = !!el.alertsEnabled.checked;
    alertsSave();
    if(alerts.enabled) alertsArmFromNow();
    alertsSetStatus(alerts.enabled ? "Alerts enabled." : "Alerts disabled.");
  });

  // Mentions quick toggle
  el.mentionsEnabled?.addEventListener("change", () => {
    mentionsReadFromUI();
    mentionsSave();
    if(mentions.enabled) alertsArmFromNow();
    mentionsSetStatus(mentions.enabled ? "Mentions enabled." : "Mentions disabled.");
  });

  el.mentionsSave?.addEventListener("click", () => {
    mentionsReadFromUI();
    mentionsSave();
    if(mentions.enabled) alertsArmFromNow();
    const n = mentions.names.length;
    mentionsSetStatus(n ? `Saved (${n} name${n===1?"":"s"}).` : "Saved (no names set).");
  });

  el.alertsArm?.addEventListener("click", () => {
    alertsArmFromNow();
  });

  el.addRule?.addEventListener("click", () => alertsOpenEditor(null));
  el.ruleCancel?.addEventListener("click", () => { alertsCloseEditor(); alertsSetStatus(""); });

  // Rule sound controls
  el.ruleActSound?.addEventListener("change", () => {
    ruleSoundShowIfNeeded();
  });

  el.ruleSoundChoose?.addEventListener("click", () => {
    // Must be a user gesture; open file picker
    el.ruleSoundFile?.click();
  });

  el.ruleSoundFile?.addEventListener("change", () => {
    const f = el.ruleSoundFile.files && el.ruleSoundFile.files[0];
    if(!f) return;
    const reader = new FileReader();
    reader.onload = () => {
      ruleSoundSet(reader.result, f.name || "sound");
      alertsSetStatus("Sound loaded for this rule.");
    };
    reader.onerror = () => {
      alertsSetStatus("Could not read the selected sound file.");
    };
    reader.readAsDataURL(f);
    // Reset so choosing the same file again still triggers change
    el.ruleSoundFile.value = "";
  });

  el.ruleSoundClear?.addEventListener("click", () => {
    ruleSoundSet("", "");
    alertsSetStatus("Rule sound cleared.");
  });
  el.ruleSave?.addEventListener("click", () => {
    const data = alertsReadEditor();
    alertsUpsertRule(data);
    alertsCloseEditor();
    alertsSetStatus(`Saved rule ‚Äú${data.name}‚Äù.`);
    // Ensure alerts are enabled if the user creates rules
    if(!alerts.enabled){
      alerts.enabled = true;
      if(el.alertsEnabled) el.alertsEnabled.checked = true;
      alertsSave();
      alertsArmFromNow();
    }
  });

  // Arm pointer on first init (so we don't trigger on historical lines)
  alertsArmFromNow();
}


// If the user navigates away, stop speaking to avoid "ghost" speech.
window.addEventListener("beforeunload", () => {
  try{ if(ttsSupported()) speechSynthesis.cancel(); }catch(e){}
});

function normalizeChannel(ch){ return (ch||"Unparsed").trim().replace(/^\[|\]$/g, ""); }

function hslToRgb(h, s, l){
  // h:0-360, s/l:0-100
  h = (h % 360 + 360) % 360;
  s /= 100; l /= 100;
  const c = (1 - Math.abs(2*l - 1)) * s;
  const x = c * (1 - Math.abs((h/60) % 2 - 1));
  const m = l - c/2;
  let r=0,g=0,b=0;
  if(h < 60){ r=c; g=x; b=0; }
  else if(h < 120){ r=x; g=c; b=0; }
  else if(h < 180){ r=0; g=c; b=x; }
  else if(h < 240){ r=0; g=x; b=c; }
  else if(h < 300){ r=x; g=0; b=c; }
  else { r=c; g=0; b=x; }
  return [Math.round((r+m)*255), Math.round((g+m)*255), Math.round((b+m)*255)];
}

function channelColors(channelName){
  const n = (channelName || "unparsed").toLowerCase();

  // User override (stored locally)
  const ov = state.colorOverrides?.get?.(n);
  if(ov){
    const rgb = hexToRgb(ov);
    if(rgb){
      const [r,g,b] = rgb;
      return {
        text: `rgba(${r},${g},${b},0.92)`,
        border: `rgba(${r},${g},${b},0.35)`,
        bg: `rgba(${r},${g},${b},0.10)`,
        edge: `rgba(${r},${g},${b},0.78)`,
      };
    }
  }

  // Hand-picked to match the vibe of the existing UI, but every channel gets a color.
  const preset = {
    "global": [96,165,250],
    "help": [34,197,94],
    "nearby": [244,63,94],
    "status": [245,158,11],
    "guild": [168,85,247],
    "trade": [14,165,233],
    "tell": [251,146,60],
    "error": [248,113,113],
    "npc chatter": [250,204,21],
    "emotes": [45,212,191],
    "action emotes": [45,212,191],
  };

  let rgb = preset[n];
  if(!rgb){
    // Deterministic color for any other channel name
    let h = 2166136261; // FNV-ish
    for(let i=0;i<n.length;i++){
      h ^= n.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    const hue = (h >>> 0) % 360;
    rgb = hslToRgb(hue, 68, 58);
  }

  const [r,g,b] = rgb;
  return {
    text: `rgba(${r},${g},${b},0.92)`,
    border: `rgba(${r},${g},${b},0.35)`,
    bg: `rgba(${r},${g},${b},0.10)`,
    edge: `rgba(${r},${g},${b},0.78)`,
  };
}

function hexToRgb(hex){
  const h = (hex || "").trim();
  const m = h.match(/^#?([0-9a-f]{6})$/i);
  if(!m) return null;
  const n = parseInt(m[1], 16);
  return [(n >> 16) & 255, (n >> 8) & 255, n & 255];
}
function rgbToHex(r,g,b){
  const to = (x) => x.toString(16).padStart(2,"0");
  return "#" + to(r) + to(g) + to(b);
}
function loadColorOverrides(){
  try{
    const raw = localStorage.getItem("pg_channel_colors");
    if(!raw) return new Map();
    const obj = JSON.parse(raw);
    const m = new Map();
    for(const [k,v] of Object.entries(obj)){
      if(typeof v === "string") m.set(k.toLowerCase(), v);
    }
    return m;
  }catch(e){
    return new Map();
  }
}
let _previewRAF = 0;
function schedulePreview(){
  if(_previewRAF) return;
  _previewRAF = requestAnimationFrame(() => {
    _previewRAF = 0;
    // Re-rendering thousands of rows can be heavy; only live-preview for smaller logs.
    if((state.all?.length || 0) <= 2000){
      renderTabs();
      renderViewer();
    }
  });
}

function saveColorOverrides(){
  const obj = {};
  for(const [k,v] of state.colorOverrides.entries()){
    obj[k] = v;
  }
  localStorage.setItem("pg_channel_colors", JSON.stringify(obj));
}

function renderColorPickers(){
  if(!el.colorList) return;

  // Channels come from the loaded log. If none loaded yet, show a placeholder.
  const chans = [...state.channels.keys()].sort((a,b)=>a.localeCompare(b));
  if(!chans.length){
    el.colorList.innerHTML = `<div class="muted" style="padding:6px 2px">Load a log to see channels here.</div>`;
    return;
  }

  const rows = [];
  for(const ch of chans){
    const colors = channelColors(ch);
    const key = (ch || "").toLowerCase();
    const override = state.colorOverrides.get(key) || "";
    const [r,g,b] = hexToRgb(override) || [null,null,null];
    const currentHex = (r!==null) ? override : rgbToHex(
      parseInt(colors.text.match(/\d+/g)[0]),
      parseInt(colors.text.match(/\d+/g)[1]),
      parseInt(colors.text.match(/\d+/g)[2])
    );

    rows.push(`
      <div class="colorRow" style="--dot:${colors.edge}">
        <div class="name">
          <span class="dot" aria-hidden="true"></span>
          <span>${escapeHtml(ch)}</span>
        </div>
        <div class="row" style="width:auto">
          <span class="mini">${override ? "custom" : "auto"}</span>
          <input type="color" data-channel="${escapeHtml(key)}" value="${escapeHtml(currentHex)}" />
          <button class="btn" data-clear="${escapeHtml(key)}" style="padding:8px 10px">Clear</button>
        </div>
      </div>
    `);
  }

  el.colorList.innerHTML = rows.join("");

  // Wire up color inputs
  el.colorList.querySelectorAll('input[type="color"][data-channel]').forEach(inp => {
    // While dragging in the picker, keep UI responsive.
    // - For large logs: update only the picker UI (dot/label), apply on release.
    // - For small logs: we also do a throttled live preview.
    inp.addEventListener("input", () => {
      const k = inp.getAttribute("data-channel");
      const v = inp.value;
      if(k && v){
        state.colorOverrides.set(k, v);

        // Update only this row's dot + label (no rebuild)
        const row = inp.closest(".colorRow");
        if(row){
          const c = channelColors(k);
          row.style.setProperty("--dot", c.edge);
          const mini = row.querySelector(".mini");
          if(mini) mini.textContent = "custom";
        }

        // Throttled live preview (only if log isn't huge)
        schedulePreview();
      }
    });

    // Apply + save when finished (mouse-up / picker confirmed)
    inp.addEventListener("change", () => {
      const k = inp.getAttribute("data-channel");
      const v = inp.value;
      if(k && v) state.colorOverrides.set(k, v);
      saveColorOverrides();
      renderTabs();
      renderViewer();
      // Keep the picker list stable; no need to rebuild here.
    });
  });
// Wire up per-channel clear buttons
  el.colorList.querySelectorAll('button[data-clear]').forEach(btn => {
    btn.addEventListener("click", () => {
      const k = btn.getAttribute("data-clear");
      if(k){
        state.colorOverrides.delete(k);
        saveColorOverrides();
        renderTabs();
        renderViewer();
        renderColorPickers();
      }
    });
  });
}


function channelClass(ch){
  const x = (ch||"").toLowerCase();
  if(x === "status") return "status";
  if(x === "global") return "global";
  if(x === "help") return "help";
  if(x === "nearby") return "nearby";
  return "";
}
function escapeHtml(s){
  return (s ?? "").replace(/[&<>"']/g, (c) => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
  }[c]));
}

// -----------------------------
// Tutorial (pre-load + on-demand)
// -----------------------------
const TUTORIAL_HIDE_KEY = "pgcv_tutorial_hidden_v1";

function tutorialHiddenPersisted(){
  return localStorage.getItem(TUTORIAL_HIDE_KEY) === "1";
}

function tutorialMarkup(){
  return `
    <div class="tutorialCard" role="dialog" aria-label="Quick tutorial">
      <div class="tutorialHead">
        <div>
          <h2 class="tutorialTitle">Quick start</h2>
          <div class="note" style="margin-top:4px">This viewer runs locally in your browser ‚Äî nothing is uploaded.</div>
        </div>
        <button class="tutorialClose" id="tutorialClose" title="Close">√ó</button>
      </div>

      <div class="tutorialGrid">
        <div class="tutorialBlock">
          <h3>Recommended (best live updates)</h3>
          <ul>
            <li>Click <b>üìÅ Choose folder</b>, select your chat log folder, then click a file in the list.</li>
            <li>If you see <b>üîì Grant access</b>, click it (browser security requires a user gesture).</li>
            <li><b>Auto-refresh</b> is on by default at the bottom to append new lines as they arrive.</li>
          </ul>
        </div>

        <div class="tutorialBlock">
          <h3>Other ways to load</h3>
          <ul>
            <li><b>üìÑ Load log file</b> (single file picker)</li>
            <li>Drag & drop a log onto the page</li>
            <li>Paste raw log text and click <b>Parse Paste</b></li>
          </ul>
        </div>

        <div class="tutorialBlock">
          <h3>Tips</h3>
          <ul>
            <li>Search filters the <b>current tab</b>.</li>
            <li><b>Read aloud (Text-to-Speech)</b>: Set your options first, then press <b>‚ñ∂ Play</b> to start reading.</li>
            <li><b>Scope</b>: Current tab reads only the tab you‚Äôre viewing; All channels reads across the entire log (if your tab is All, both effectively mean everything).</li>
            <li><b>Filters</b>: Speaker accepts Name or Name: (colon ignored) and reads only the message text (not the name). Optional channel filter narrows further.</li>
            <li><b>Live ‚Äúfrom now‚Äù</b>: when you press Play, it starts at the bottom and reads only new matching lines arriving after that.</li>
            <li><b>Voice + speed</b>: choose a voice and adjust rate for comfort.</li>
            <li><b>Performance mode</b> keeps huge logs smooth and only renders what is on screen (click a line to see full text). Only use if your log becomes laggy.</li>
          </ul>
        </div>

        <div class="tutorialBlock">
          <h3>Tips Continued</h3>
          <ul>
            <li>Folder live mode works best in <b>Chromium</b> browsers (Edge, Opera, Chrome, etc.).</li>
            <li>In <b>Firefox</b>, use <b>Load</b> / <b>Drag &amp; drop</b> (folder handles are limited). Live chat may not work.</li>
            <li><b>Add rule mode</b>: Make your own rules and play a custom sound instead of speech (or alongside it).</li>
            <li>Remember to enable <b>Enable alerts</b>, then save the rule. Rules can be edited.</li>
          </ul>
        </div>
      </div>

      <div class="tutorialActions">
        <button class="btn small ghost" id="tutorialDontShow">Don‚Äôt show again</button>
        <button class="btn small" id="tutorialGotIt">Got it</button>
      </div>
    </div>
  `;
}

function renderTutorialOverlay(){
  if(!el.tutorialOverlay) return;

  const show =
    (state.tutorialOverride === true) ||
    (state.tutorialOverride === null && !tutorialHiddenPersisted() && !state.tutorialDismissed && state.all.length === 0);

  el.tutorialOverlay.style.display = show ? "flex" : "none";
  if(!show){
    el.tutorialOverlay.innerHTML = "";
    return;
  }

  // Render and wire buttons
  if(!el.tutorialOverlay.innerHTML){
    el.tutorialOverlay.innerHTML = tutorialMarkup();

    const close = el.tutorialOverlay.querySelector("#tutorialClose");
    const gotIt = el.tutorialOverlay.querySelector("#tutorialGotIt");
    const dont = el.tutorialOverlay.querySelector("#tutorialDontShow");

    const hideForSession = () => {
      state.tutorialDismissed = true;
      state.tutorialOverride = false;
      renderTutorialOverlay();
    };

    close?.addEventListener("click", hideForSession);
    gotIt?.addEventListener("click", hideForSession);

    dont?.addEventListener("click", () => {
      localStorage.setItem(TUTORIAL_HIDE_KEY, "1");
      hideForSession();
    });
  }
}

function showTutorial(){
  // show on-demand even if user previously hid it
  state.tutorialDismissed = false;
  state.tutorialOverride = true;
  renderTutorialOverlay();
}

function maybeAutoTutorialReset(){
  // If we were forcing the tutorial open and data is now loaded, keep it until user closes.
  // If tutorial was auto (override=null), it will naturally disappear once state.all has data.
  if(state.tutorialOverride === false && state.all.length > 0){
    // once data is loaded, we can reset to auto mode
    state.tutorialOverride = null;
  }
}

function parseLine(line){
  const m = line.match(/^(\S+\s+\S+)\s*\t\s*\[([^\]]+)\]\s*(.*)$/);
  if(!m) return { raw: line, ts: "", channel: "Unparsed", from: "", text: line.trim(), kind: "unparsed" };
  const ts = m[1];
  const channel = normalizeChannel(m[2]);
  const rest = (m[3] ?? "").trim();

  let from = "", text = rest;
  const m2 = rest.match(/^([^:]{1,60}):\s*(.*)$/);
  if(m2 && channel.toLowerCase() !== "status"){ from = m2[1].trim(); text = m2[2] ?? ""; }
  const kind = channel.toLowerCase() === "status" ? "status" : "chat";
  return { raw: line, ts, channel, from, text, kind };
}
function parseText(text){
  const lines = text.replace(/\r\n/g,"\n").split("\n").filter(l => l.trim().length > 0);
  return lines.map(parseLine);
}
function rebuildIndex(){
  state.channels = new Map();
  for(const item of state.all){
    const ch = item.channel || "Unparsed";
    if(!state.channels.has(ch)) state.channels.set(ch, []);
    state.channels.get(ch).push(item);
  }
}
function renderTabs(){
  const counts = new Map(state.channels);
  const allCount = state.all.length;
  const channelsSorted = [...counts.keys()].sort((a,b) => a.localeCompare(b));
  const tabs = ["All", ...channelsSorted];

  const sumUnread = () => {
    let s = 0;
    for(const v of state.unreadCounts.values()) s += (v || 0);
    return s;
  };

  el.tabs.innerHTML = "";
  for(const name of tabs){
    const btn = document.createElement("div");
    const isActive = (name === state.activeChannel);
    btn.className = "tab" + (isActive ? " active" : "");

    const total = name === "All" ? allCount : (counts.get(name)?.length ?? 0);

    let unread = 0;
    if(name === "All"){
      unread = (state.activeChannel === "All") ? 0 : sumUnread();
    }else{
      unread = isActive ? 0 : (state.unreadCounts.get(name) || 0);
    }

    if(unread > 0) btn.classList.add("unread");

    btn.innerHTML =
      `<span>${escapeHtml(name)}</span>` +
      `<span class="badge">${total}</span>` +
      (unread > 0 ? `<span class="badge new">+${unread}</span>` : ``);

    btn.addEventListener("click", () => {
      if(name === "All") state.unreadCounts.clear();
      else state.unreadCounts.set(name, 0);
      state.activeChannel = name;
      renderTabs();
      renderViewer();
    });

    el.tabs.appendChild(btn);
  }
}

function activeItems(){
  let items = state.activeChannel === "All" ? state.all : (state.channels.get(state.activeChannel) ?? []);
  const q = state.search.trim().toLowerCase();
  const qNoColon = q.replace(/:+\s*$/,""); // lets "Name:" match speaker "Name"
  if(q){
    items = items.filter(it => {
      const ts = (it.ts || "").toLowerCase();
      const ch = (it.channel || "").toLowerCase();
      const from = (it.from || "").toLowerCase();
      const msg = (it.text || "").toLowerCase();

      return ts.includes(q) ||
             ch.includes(q) ||
             from.includes(qNoColon || q) ||
             msg.includes(q);
    });
  }
  return items;
}
// -----------------------------
// Performance mode (virtualized rendering)
// -----------------------------
const virt = {
  top: null,
  mid: null,
  bottom: null,
  items: [],
  rowHeight: 32,
  overscan: 12,
  compact: false,
  bound: false,
  raf: 0,
};

function perfEnabled(){
  return !!(el.performance && el.performance.checked);
}

function clearHighlightClassesIn(container){
  for(const r of container.querySelectorAll(".msg.tts-speaker")) r.classList.remove("tts-speaker");
  for(const r of container.querySelectorAll(".msg.tts-hit")) r.classList.remove("tts-hit");
}

function applyHighlightClassesToRow(row, it){
  const now = Date.now();
  if(state.ttsHiUntil && now < state.ttsHiUntil){
    if(state.ttsHiSpeakerKey && (row.dataset.fromkey || "") === state.ttsHiSpeakerKey){
      row.classList.add("tts-speaker");
    }
    if(state.ttsHiItemId != null && it && it.id != null && String(it.id) === String(state.ttsHiItemId)){
      row.classList.add("tts-hit");
    }
  }
}

function buildRow(it, compact){
  const row = document.createElement("div");
  row.className = "msg";

  // Data attributes for live features (TTS highlight, etc.)
  if(it.id != null) row.dataset.id = String(it.id);
  const _spkKey = (typeof ttsNormalizeKey === "function" ? ttsNormalizeKey(ttsSpeakerOf(it)) : ((it.from||"").toLowerCase()));
  if(_spkKey) row.dataset.fromkey = _spkKey;
  if(it.channel) row.dataset.channel = String(it.channel).toLowerCase();

  if(compact){
    row.style.gridTemplateColumns = "135px 95px 1fr";
    row.style.padding = "8px 10px";
    row.style.fontSize = "12px";
  }

  const colors = channelColors(it.channel);
  row.style.setProperty('--c', colors.text);
  row.style.setProperty('--cBorder', colors.border);
  row.style.setProperty('--cBg', colors.bg);
  row.style.setProperty('--cEdge', colors.edge);

  const pillClass = channelClass(it.channel); // kept for optional per-channel overrides
  const chanPill = `<span class="pill ${pillClass}">[${escapeHtml(it.channel)}]</span>`;
  let who = it.from ? `<span class="from">${escapeHtml(it.from)}:</span> ` : "";
  let text = escapeHtml(it.text);
  if(it.kind === "status"){ who = ""; text = `<span class="statusLine">${text}</span>`; }

  row.innerHTML = `
    <div class="ts">${escapeHtml(it.ts)}</div>
    <div class="chan">${chanPill}</div>
    <div class="text">${who}${text}</div>
  `;

  // Full-text helper for Performance mode (rows may be ellipsized)
  const plain = (() => {
    const ch = it.channel || "Unparsed";
    // Unread tracking: if you are not on this channel tab (and not on All), count it as unread.
    if(state.activeChannel !== "All" && ch !== state.activeChannel){
      state.unreadCounts.set(ch, (state.unreadCounts.get(ch) || 0) + 1);
    }
    const speakerPart = (it.kind === "status" || !it.from) ? "" : (it.from + ": ");
    const body = (it.text || "");
    return `${it.ts} [${ch}] ${speakerPart}${body}`;
  })();
  row.dataset.preview = plain;
  row.title = plain;

  applyHighlightClassesToRow(row, it);
  return row;
}

function ensureVirtScaffold(){
  if(virt.top && virt.mid && virt.bottom) return;

  el.viewer.innerHTML = "";
  virt.top = document.createElement("div");
  virt.mid = document.createElement("div");
  virt.bottom = document.createElement("div");

  // spacers
  virt.top.style.height = "0px";
  virt.bottom.style.height = "0px";

  el.viewer.appendChild(virt.top);
  el.viewer.appendChild(virt.mid);
  el.viewer.appendChild(virt.bottom);

  if(!virt.bound){
    el.viewer.addEventListener("scroll", () => {
      if(!perfEnabled()) return;
      if(virt.raf) cancelAnimationFrame(virt.raf);
      virt.raf = requestAnimationFrame(() => {
        virt.raf = 0;
        virtRender();
      });
    }, { passive: true });
    virt.bound = true;
  }
}

function virtRender(){
  if(!perfEnabled()){
    return;
  }
  ensureVirtScaffold();

  const items = virt.items || [];
  const total = items.length;
  const rowH = Math.max(18, Number(virt.rowHeight) || 32);
  const st = el.viewer.scrollTop;
  const vh = el.viewer.clientHeight;

  const start = Math.max(0, Math.floor(st / rowH) - virt.overscan);
  const end = Math.min(total, Math.ceil((st + vh) / rowH) + virt.overscan);

  virt.top.style.height = (start * rowH) + "px";
  virt.bottom.style.height = ((total - end) * rowH) + "px";

  // Render visible slice
  virt.mid.innerHTML = "";
  for(let i=start; i<end; i++){
    virt.mid.appendChild(buildRow(items[i], virt.compact));
  }
}

function renderViewer(){
  const items = activeItems();
  const compact = el.compact.checked;
  const wantAuto = el.autoscroll.checked;
  const perf = perfEnabled();

  // "near bottom" based on current scroll metrics
  const wasNearBottom = wantAuto && (el.viewer.scrollTop + el.viewer.clientHeight >= el.viewer.scrollHeight - 40);

  if(!perf){
    el.viewer.classList.remove("perf");
    el.viewer.style.removeProperty("--rowH");

    // tear down virt state (keep bound scroll handler; it is gated by perfEnabled())
    virt.items = [];
    virt.compact = compact;

    el.viewer.innerHTML = "";
    for(const it of items){
      el.viewer.appendChild(buildRow(it, compact));
    }
  }else{
    el.viewer.classList.add("perf");
    // Fixed row height so virtualization stays accurate
    const rowH = compact ? 26 : 32;
    el.viewer.style.setProperty("--rowH", rowH + "px");
    virt.items = items;
    virt.rowHeight = rowH;
    virt.compact = compact;

    ensureVirtScaffold();
    virtRender();
  }

  el.count.textContent = String(state.all.length);
  const chCount = state.channels.size;
  const showing = items.length;
  el.stats.textContent = state.all.length
    ? `Channels: ${chCount} ¬∑ Showing: ${showing} ¬∑ Active: ${state.activeChannel}${state.search ? " ¬∑ Search: ‚Äú" + state.search + "‚Äù" : ""}`
    : "No data loaded.";

  renderTutorialOverlay();
  maybeAutoTutorialReset();

  if(wasNearBottom){
    el.viewer.scrollTop = Math.max(0, el.viewer.scrollHeight - el.viewer.clientHeight);
    if(perf) virtRender();
  }
}
function loadText(text, sourceLabel=""){
  try{ if(typeof ttsSupported === "function" && ttsSupported()) ttsStop(); }catch(e){}
  const parsed = parseText(text);
  state.all = parsed;
  state.nextId = 0;
  for(const it of state.all){ it.id = ++state.nextId; }
  rebuildIndex();
  state.unreadCounts = new Map();
  try{ if(typeof alerts !== "undefined") alerts.lastProcessedId = state.nextId || 0; }catch(e){}
  if(state.activeChannel !== "All" && !state.channels.has(state.activeChannel)) state.activeChannel = "All";
  renderTabs();
  renderViewer();
  renderColorPickers();
  if(sourceLabel) el.folderNote.textContent = `Loaded ${parsed.length} lines from ${sourceLabel}.`;
}

function appendItems(items, sourceLabel=""){
  if(!items || !items.length) return;

  // Assign stable incremental ids to new items (used for live TTS from-now behavior)
  for(const it of items){
    if(it.id == null) it.id = ++state.nextId;
    state.all.push(it);
    const ch = it.channel || "Unparsed";
    if(!state.channels.has(ch)) state.channels.set(ch, []);
    state.channels.get(ch).push(it);
  }

  renderTabs();
  renderViewer();
  renderColorPickers();

  try{ if(typeof ttsHandleNewItems === "function") ttsHandleNewItems(items); }catch(e){}

  try{ if(typeof alertsHandleNewItems === "function") alertsHandleNewItems(items); }catch(e){}

  if(sourceLabel){
    el.folderNote.textContent = `Updated from ${sourceLabel}. (+${items.length} new lines)`;
  }
}

async function loadFromFileHandle(fileHandle, label=""){
  const file = await fileHandle.getFile();
  const text = await file.text();

  state.currentFileHandle = fileHandle;
  state.currentFileName = file.name || label || "";
  state.currentFileSize = file.size;
  state.tailRemainder = "";

  loadText(text, file.name || label || "selected file");
}

async function refreshCurrentFileIncremental(){
  if(!state.currentFileHandle) return;

  try{
    const file = await state.currentFileHandle.getFile();

    if(file.size < (state.currentFileSize || 0)){
      await loadFromFileHandle(state.currentFileHandle, state.currentFileName || "current file");
      return;
    }

    if(file.size === (state.currentFileSize || 0)) return;

    const slice = file.slice(state.currentFileSize || 0, file.size);
    let chunk = await slice.text();
    if(!chunk){
      state.currentFileSize = file.size;
      return;
    }

    chunk = (state.tailRemainder || "") + chunk;

    const endsWithNewline = /\n$/.test(chunk) || /\r\n$/.test(chunk);
    chunk = chunk.replace(/\r\n/g,"\n");
    let lines = chunk.split("\n");

    if(!endsWithNewline){
      state.tailRemainder = lines.pop() || "";
    }else{
      state.tailRemainder = "";
      if(lines.length && lines[lines.length-1] === "") lines.pop();
    }

    const newItems = lines.filter(l => l.trim().length > 0).map(parseLine);
    state.currentFileSize = file.size;

    if(newItems.length){
      appendItems(newItems, file.name || state.currentFileName || "current file");
    }
  }catch(err){
    showWarning(`Auto-refresh failed. You may need to click <b>üîì Grant access</b> again. Error: <code>${escapeHtml(String(err))}</code>`, true);
    stopAutoRefresh();
  }
}

function stopAutoRefresh(){
  if(state.refreshTimer){
    clearInterval(state.refreshTimer);
    state.refreshTimer = null;
  }
}

function startAutoRefresh(){
  stopAutoRefresh();
  const ms = parseInt(el.refreshInterval?.value || "2000", 10);
  if(!state.currentFileHandle){
    showWarning(`Auto-refresh is on, but no current log is selected. Choose a file from the list first.`, true);
    return;
  }
  showWarning("", false);
  state.refreshTimer = setInterval(refreshCurrentFileIncremental, isFinite(ms) ? ms : 2000);
}


/* File input / DnD / Paste */
el.file.addEventListener("change", async (e) => {
  const file = e.target.files?.[0];
  if(!file) return;
  // File picker gives a File object, not a persistent handle; auto-refresh works best via the folder picker list.
  state.currentFileHandle = null;
  state.currentFileName = file.name || "";
  state.currentFileSize = file.size || 0;
  state.tailRemainder = "";
  loadText(await file.text(), file.name);
  if(el.autoRefresh?.checked){
    showWarning(`Auto-refresh needs a folder-selected file (Chrome/Edge/Brave). Pick a log from the folder list to enable live updates.`, true);
  }
});
["dragenter","dragover"].forEach(ev => el.drop.addEventListener(ev, (e) => { e.preventDefault(); el.drop.classList.add("drag"); }));
["dragleave","drop"].forEach(ev => el.drop.addEventListener(ev, (e) => { e.preventDefault(); el.drop.classList.remove("drag"); }));
el.drop.addEventListener("drop", async (e) => {
  const file = e.dataTransfer?.files?.[0];
  if(!file) return;
  loadText(await file.text(), file.name);
});
el.parsePaste.addEventListener("click", () => {
  const t = el.paste.value || "";
  if(t.trim()) loadText(t, "pasted text");
});
el.clear.addEventListener("click", () => {
  stopAutoRefresh();
  try{ if(typeof ttsSupported === "function" && ttsSupported()) ttsStop(); }catch(e){}
  state.all = []; state.channels = new Map(); state.unreadCounts = new Map(); state.activeChannel = "All"; state.search = "";
  el.search.value = ""; el.paste.value = "";
  renderTabs(); renderViewer(); renderColorPickers();
  el.folderNote.textContent = "Choose a folder containing your chat logs, then pick a file below.";
});
if(el.tutorialBtn) el.tutorialBtn.addEventListener("click", () => { showTutorial(); });
el.search.addEventListener("input", () => { state.search = el.search.value || ""; renderViewer(); });
// UI toggles
if(el.compact) el.compact.addEventListener("change", () => { renderViewer(); });
if(el.performance) el.performance.addEventListener("change", () => {
  localStorage.setItem("pg_perfMode", el.performance.checked ? "1" : "0");
  // Show/hide full-text preview helper when performance mode is toggled
  if(el.perfPreview){
    if(el.performance.checked){
      el.perfPreview.style.display = "flex";
      if(el.perfPreviewHint) el.perfPreviewHint.style.display = "block";
      if(el.perfPreviewBody) el.perfPreviewBody.textContent = "";
    }else{
      el.perfPreview.style.display = "none";
    }
  }
  renderViewer();
});
if(el.autoRefresh) el.autoRefresh.addEventListener("change", () => {
  if(el.autoRefresh.checked) startAutoRefresh();
  else stopAutoRefresh();
});
if(el.refreshInterval) el.refreshInterval.addEventListener("change", () => {
  if(el.autoRefresh?.checked) startAutoRefresh();
});

window.addEventListener("keydown", (e) => {
  if(e.key === "Escape"){ state.search = ""; el.search.value = ""; renderViewer(); }
  if(e.key === "Enter" && (e.metaKey || e.ctrlKey)) el.autoscroll.checked = !el.autoscroll.checked;
});

// Performance mode full-text preview (click a row to show full message)
if(el.perfPreviewClose) el.perfPreviewClose.addEventListener("click", () => {
  if(el.perfPreview) el.perfPreview.style.display = "none";
});
if(el.viewer) el.viewer.addEventListener("click", (e) => {
  if(!perfEnabled()) return;
  const row = e.target.closest(".msg");
  if(!row) return;
  const txt = row.dataset.preview || row.title || "";
  if(!txt) return;
  if(el.perfPreview){
    el.perfPreview.style.display = "flex";
    if(el.perfPreviewHint) el.perfPreviewHint.style.display = "none";
    if(el.perfPreviewBody) el.perfPreviewBody.textContent = txt;
  }
});


/* Folder picker persistence (Chromium File System Access API) */
function showWarning(msg, show=true){
  el.folderWarning.style.display = show ? "block" : "none";
  el.folderWarning.innerHTML = msg ? msg : "";
}
function supportsFolderPicker(){ return !!window.showDirectoryPicker; }

const DB_NAME = "pg_chat_viewer_db", STORE = "handles", KEY = "dir";
function idbOpen(){
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if(!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}
async function idbSet(key, value){
  const db = await idbOpen();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, "readwrite");
    tx.objectStore(STORE).put(value, key);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}
async function idbGet(key){
  const db = await idbOpen();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, "readonly");
    const req = tx.objectStore(STORE).get(key);
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}
async function ensurePermission(handle, request=false){
  if(!handle) return false;
  const opts = { mode: "read" };

  // First, only *check* permission.
  if(handle.queryPermission){
    const q = await handle.queryPermission(opts);
    if(q === "granted") return true;
    // Only request permission if explicitly asked (must be user-initiated).
    if(request && handle.requestPermission){
      const r = await handle.requestPermission(opts);
      return r === "granted";
    }
    return false;
  }

  // Older implementations: best effort
  return true;
}
function looksLikeLogFile(name){
  const n = name.toLowerCase();
  return n.endsWith(".log") || n.endsWith(".txt");
}
async function listFilesInFolder(dirHandle){
  const files = [];
  for await (const [name, handle] of dirHandle.entries()){
    if(handle.kind === "file" && looksLikeLogFile(name)){
      const file = await handle.getFile();
      files.push({ name, handle, size: file.size, modified: file.lastModified ? new Date(file.lastModified) : null });
    }
  }
  files.sort((a,b) => (b.modified?.getTime()||0) - (a.modified?.getTime()||0) || a.name.localeCompare(b.name));
  return files;
}
function fmtBytes(bytes){
  if(bytes < 1024) return bytes + " B";
  const kb = bytes / 1024;
  if(kb < 1024) return kb.toFixed(1) + " KB";
  const mb = kb / 1024;
  return mb.toFixed(1) + " MB";
}
function fmtDate(d){ return d ? d.toLocaleString() : ""; }

async function renderFileList(requestPermission=false){
  el.fileList.innerHTML = "";
  if(!state.dirHandle){
    el.fileList.innerHTML = `<div class="fileItem" style="cursor:default;color:var(--muted)">No folder selected.</div>`;
    el.refreshFolder.disabled = true;
    el.grantAccess.disabled = true;
    return;
  }
  el.refreshFolder.disabled = false;

  try{
    const ok = await ensurePermission(state.dirHandle, requestPermission);
    if(!ok){
      // We can *not* request permission on page load; user must click Grant access.
      showWarning(`Folder permission is needed. Click <b>üîì Grant access</b> (or <b>Choose folder</b>) and approve the prompt.`);
      el.fileList.innerHTML = `<div class="fileItem" style="cursor:default;color:var(--muted)">Permission needed.</div>`;
      el.grantAccess.disabled = false;
      return;
    }
    el.grantAccess.disabled = true;
    showWarning("", false);
    const files = await listFilesInFolder(state.dirHandle);
    if(!files.length){
      el.fileList.innerHTML = `<div class="fileItem" style="cursor:default;color:var(--muted)">No .log or .txt files found in that folder.</div>`;
      return;
    }
    for(const f of files){
      const div = document.createElement("div");
      div.className = "fileItem";
      div.innerHTML = `<span>${escapeHtml(f.name)}</span><span class="fileMeta">${fmtBytes(f.size)} ¬∑ ${escapeHtml(fmtDate(f.modified))}</span>`;
      div.addEventListener("click", async () => {
        try{
          await loadFromFileHandle(f.handle, f.name);
          if(el.autoRefresh?.checked){ startAutoRefresh(); }
        }catch(err){
          showWarning(`Could not read that file. Error: <code>${escapeHtml(String(err))}</code>`);
        }
      });
      el.fileList.appendChild(div);
    }
  }catch(err){
    showWarning(`Folder scan failed. Error: <code>${escapeHtml(String(err))}</code>`);
  }
}

el.chooseFolder.addEventListener("click", async () => {
  if(!supportsFolderPicker()){
    showWarning(
      `Folder picking isn't available in this browser/context. Try Chrome/Edge/Brave, and ideally open this page via <code>http://localhost</code>.<br><br>
       Quick local server: <code>python -m http.server 8000</code> then open <code>http://localhost:8000</code>.`
    );
    return;
  }
  try{
    const dir = await window.showDirectoryPicker({ mode: "read" });
    state.dirHandle = dir;
    await idbSet(KEY, dir);
    showWarning("", false);
    el.folderNote.textContent = "Folder selected. Click a file to load it.";
    el.grantAccess.disabled = true;
    await renderFileList(false);
  }catch(err){
    // user cancelled is fine
  }
});
el.refreshFolder.addEventListener("click", async () => { await renderFileList(true); });

el.grantAccess.addEventListener("click", async () => {
  await renderFileList(true);
});


function initCollapsibles(){
  const defaults = { folderBox:true, channelColorsBox:false, ttsBox:false, alertsBox:false };
  for(const sec of Object.keys(defaults)){
    const body = document.querySelector(`[data-sec-body="${sec}"]`);
    const btn = document.querySelector(`button[data-sec="${sec}"]`);
    if(!body || !btn) continue;
    const key = `pg_sec_${sec}`;
    const saved = localStorage.getItem(key);
    const isOpen = (saved === null) ? !!defaults[sec] : (saved === "1");
    const setState = (open)=>{
      body.classList.toggle("isCollapsed", !open);
      btn.textContent = open ? "‚ñæ" : "‚ñ∏";
      localStorage.setItem(key, open ? "1" : "0");
    };
    setState(isOpen);
    btn.addEventListener("click", (e)=>{
      e.preventDefault();
      setState(body.classList.contains("isCollapsed"));
    });
  }
}

// Init
(async function init(){
  state.colorOverrides = loadColorOverrides();
  initCollapsibles();
  if(el.performance) el.performance.checked = (localStorage.getItem("pg_perfMode") === "1");
  if(el.perfPreview){
    el.perfPreview.style.display = (el.performance && el.performance.checked) ? "flex" : "none";
    if(el.perfPreviewHint) el.perfPreviewHint.style.display = (el.performance && el.performance.checked) ? "block" : "none";
  }
  renderTabs(); renderViewer(); renderColorPickers();
  initTTS();
  initAlerts();
  if(!supportsFolderPicker()){
    showWarning(`Folder picker isn't available here. You can still use <b>Load log file</b> or drag & drop.`, true);
    el.grantAccess.disabled = true;
    await renderFileList(false);
    return;
  }
  try{
    const saved = await idbGet(KEY);
    if(saved){
      state.dirHandle = saved;
      const ok = await ensurePermission(saved);
      if(ok){
        el.folderNote.textContent = "Restored previous folder. Click a file to load it.";
      }else{
        el.folderNote.textContent = "Previous folder found, but permission is needed.";
        showWarning(`Click <b>Choose folder</b> and approve permission to restore access.`, true);
      }
    }
    el.grantAccess.disabled = true;
    await renderFileList(false);
  }catch(err){
    showWarning(`Could not restore folder selection. Error: <code>${escapeHtml(String(err))}</code>`, true);
    el.grantAccess.disabled = true;
    await renderFileList(false);
  }
})();
</script>
</body>
</html>
